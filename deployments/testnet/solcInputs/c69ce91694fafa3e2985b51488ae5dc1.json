{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Amm.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {IPriceFeed} from \"./interfaces/IPriceFeed.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"./utils/Decimal.sol\";\nimport {SignedDecimal} from \"./utils/SignedDecimal.sol\";\nimport {MixedDecimal} from \"./utils/MixedDecimal.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {IAmm} from \"./interfaces/IAmm.sol\";\n\n// solhint-disable-next-line max-states-count\ncontract Amm is IAmm, OwnableUpgradeable {\n    using Decimal for Decimal.decimal;\n    using SignedDecimal for SignedDecimal.signedDecimal;\n    using MixedDecimal for SignedDecimal.signedDecimal;\n\n    enum QuoteAssetDir {\n        QUOTE_IN,\n        QUOTE_OUT\n    }\n\n    enum TwapCalcOption {\n        RESERVE_ASSET,\n        INPUT_ASSET\n    }\n\n    struct ReserveSnapshot {\n        Decimal.decimal quoteAssetReserve;\n        Decimal.decimal baseAssetReserve;\n        uint256 timestamp;\n        uint256 blockNumber;\n    }\n\n    struct TwapInputAsset {\n        Dir dir;\n        Decimal.decimal assetAmount;\n        QuoteAssetDir inOrOut;\n    }\n\n    struct TwapPriceCalcParams {\n        TwapCalcOption opt;\n        uint256 snapshotIndex;\n        TwapInputAsset asset;\n    }\n\n    struct DynamicFeeSettings {\n        Decimal.decimal divergenceThresholdRatio;\n        Decimal.decimal feeRatio;\n        Decimal.decimal feeInFavorRatio;\n    }\n\n    struct FundingRate {\n        SignedDecimal.signedDecimal fundingRateLong;\n        SignedDecimal.signedDecimal fundingRateShort;\n    }\n\n    /**\n     * below state variables cannot change their order\n     */\n\n    // ratios\n    Decimal.decimal internal feeRatio;\n    Decimal.decimal public tradeLimitRatio;\n    Decimal.decimal public fluctuationLimitRatio;\n    Decimal.decimal internal initMarginRatio;\n    Decimal.decimal internal maintenanceMarginRatio;\n    Decimal.decimal internal partialLiquidationRatio;\n    Decimal.decimal internal liquidationFeeRatio;\n\n    // dynamic fees\n    DynamicFeeSettings public level1DynamicFeeSettings;\n    DynamicFeeSettings public level2DynamicFeeSettings;\n\n    // funding rate\n    FundingRate public fundingRate;\n\n    // x and y\n    Decimal.decimal public quoteAssetReserve;\n    Decimal.decimal public baseAssetReserve;\n    Decimal.decimal public k;\n\n    // caps\n    Decimal.decimal internal maxHoldingBaseAsset;\n    Decimal.decimal internal openInterestNotionalCap;\n\n    SignedDecimal.signedDecimal public totalPositionSize;\n    SignedDecimal.signedDecimal public cumulativeNotional;\n    SignedDecimal.signedDecimal public baseAssetDeltaThisFundingPeriod;\n    Decimal.decimal public _x0;\n    Decimal.decimal public _y0;\n\n    uint256 public override fundingPeriod;\n    uint256 public markPriceTwapInterval;\n    uint256 public nextFundingTime;\n    uint256 public fundingBufferPeriod;\n    uint256 public lastRepegTimestamp;\n    uint256 public repegBufferPeriod;\n    IPriceFeed public priceFeed;\n    bytes32 public priceFeedKey;\n    address public counterParty;\n    IERC20 public override quoteAsset;\n    bool public override open;\n\n    ReserveSnapshot[] public reserveSnapshots;\n\n    // events\n    event Open(bool indexed open);\n    event SwapInput(Dir dir, uint256 quoteAssetAmount, uint256 baseAssetAmount);\n    event SwapOutput(\n        Dir dir,\n        uint256 quoteAssetAmount,\n        uint256 baseAssetAmount\n    );\n    event FundingRateUpdated(\n        int256 fundingRateLong,\n        int256 fundingRateShort,\n        uint256 underlyingPrice\n    );\n    event ReserveSnapshotted(\n        uint256 quoteAssetReserve,\n        uint256 baseAssetReserve,\n        uint256 timestamp\n    );\n    event FeeRatioChanged(uint256 ratio);\n    event TradeLimitRatioChanged(uint256 ratio);\n    event FluctuationLimitRatioChanged(uint256 ratio);\n    event InitMarginRatioChanged(uint256 ratio);\n    event MaintenanceMarginRatioChanged(uint256 ratio);\n    event PartialLiquidationRatioChanged(uint256 ratio);\n    event LiquidationFeeRatioChanged(uint256 ratio);\n    event Level1DynamicFeeSettingsChanged(\n        uint256 divergenceThresholdRatio,\n        uint256 feeRatio,\n        uint256 feeInFavorRatio\n    );\n    event Level2DynamicFeeSettingsChanged(\n        uint256 divergenceThresholdRatio,\n        uint256 feeRatio,\n        uint256 feeInFavorRatio\n    );\n    event FundingPeriodChanged(uint256 fundingPeriod);\n    event CapChanged(\n        uint256 maxHoldingBaseAsset,\n        uint256 openInterestNotionalCap\n    );\n    event PriceFeedUpdated(address indexed priceFeed);\n    event Repeg(\n        uint256 quoteAssetReserveBefore,\n        uint256 baseAssetReserveBefore,\n        uint256 quoteAssetReserveAfter,\n        uint256 baseAssetReserveAfter,\n        int256 repegPnl\n    );\n\n    modifier onlyOpen() {\n        require(open, \"amm was closed\");\n        _;\n    }\n\n    modifier onlyCounterParty() {\n        require(counterParty == _msgSender(), \"caller is not counterParty\");\n        _;\n    }\n\n    //\n    // EXTERNAL\n    //\n\n    /**\n     * upgradeable constructor, can only be inited once\n     */\n    function initialize(\n        uint256 _quoteAssetReserve,\n        uint256 _baseAssetReserve,\n        uint256 _tradeLimitRatio,\n        uint256 _fundingPeriod,\n        IPriceFeed _priceFeed,\n        bytes32 _priceFeedKey,\n        address _quoteAsset,\n        uint256 _fluctuationLimitRatio,\n        uint256 _feeRatio\n    ) public initializer {\n        require(\n            _quoteAssetReserve != 0 &&\n                _tradeLimitRatio != 0 &&\n                _baseAssetReserve != 0 &&\n                _fundingPeriod != 0 &&\n                address(_priceFeed) != address(0) &&\n                _quoteAsset != address(0),\n            \"invalid input\"\n        );\n        __Ownable_init();\n\n        quoteAssetReserve = Decimal.decimal(_quoteAssetReserve);\n        baseAssetReserve = Decimal.decimal(_baseAssetReserve);\n        k = quoteAssetReserve.mulD(baseAssetReserve);\n        tradeLimitRatio = Decimal.decimal(_tradeLimitRatio);\n        feeRatio = Decimal.decimal(_feeRatio);\n        fluctuationLimitRatio = Decimal.decimal(_fluctuationLimitRatio);\n        fundingPeriod = _fundingPeriod;\n        fundingBufferPeriod = _fundingPeriod / 2;\n        repegBufferPeriod = 12 hours;\n        markPriceTwapInterval = fundingPeriod;\n        priceFeedKey = _priceFeedKey;\n        quoteAsset = IERC20(_quoteAsset);\n        priceFeed = _priceFeed;\n        reserveSnapshots.push(\n            ReserveSnapshot(\n                quoteAssetReserve,\n                baseAssetReserve,\n                block.timestamp,\n                block.number\n            )\n        );\n        emit ReserveSnapshotted(\n            quoteAssetReserve.toUint(),\n            baseAssetReserve.toUint(),\n            block.timestamp\n        );\n        _x0 = Decimal.decimal(_baseAssetReserve);\n        _y0 = Decimal.decimal(_quoteAssetReserve);\n    }\n\n    /**\n     * @notice Swap your quote asset to base asset, the impact of the price MUST be less than `fluctuationLimitRatio`\n     * @dev Only clearingHouse can call this function\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short\n     * @param _quoteAssetAmount quote asset amount\n     * @param _baseAssetAmountLimit minimum base asset amount expected to get to prevent front running\n     * @param _canOverFluctuationLimit if tx can go over fluctuation limit once; for partial liquidation\n     * @return base asset amount\n     */\n    function swapInput(\n        Dir _dirOfQuote,\n        Decimal.decimal calldata _quoteAssetAmount,\n        Decimal.decimal calldata _baseAssetAmountLimit,\n        bool _canOverFluctuationLimit\n    )\n        external\n        override\n        onlyOpen\n        onlyCounterParty\n        returns (Decimal.decimal memory)\n    {\n        if (_quoteAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n        if (_dirOfQuote == Dir.REMOVE_FROM_AMM) {\n            require(\n                quoteAssetReserve.mulD(tradeLimitRatio).toUint() >=\n                    _quoteAssetAmount.toUint(),\n                \"over trading limit\"\n            );\n        }\n\n        Decimal.decimal memory baseAssetAmount = getInputPrice(\n            _dirOfQuote,\n            _quoteAssetAmount\n        );\n        // If LONG, exchanged base amount should be more than _baseAssetAmountLimit,\n        // otherwise(SHORT), exchanged base amount should be less than _baseAssetAmountLimit.\n        // In SHORT case, more position means more debt so should not be larger than _baseAssetAmountLimit\n        if (_baseAssetAmountLimit.toUint() != 0) {\n            if (_dirOfQuote == Dir.ADD_TO_AMM) {\n                require(\n                    baseAssetAmount.toUint() >= _baseAssetAmountLimit.toUint(),\n                    \"Less than minimal base token\"\n                );\n            } else {\n                require(\n                    baseAssetAmount.toUint() <= _baseAssetAmountLimit.toUint(),\n                    \"More than maximal base token\"\n                );\n            }\n        }\n\n        _updateReserve(\n            _dirOfQuote,\n            _quoteAssetAmount,\n            baseAssetAmount,\n            _canOverFluctuationLimit\n        );\n        emit SwapInput(\n            _dirOfQuote,\n            _quoteAssetAmount.toUint(),\n            baseAssetAmount.toUint()\n        );\n        return baseAssetAmount;\n    }\n\n    /**\n     * @notice swap your base asset to quote asset; NOTE it is only used during close/liquidate positions so it always allows going over fluctuation limit\n     * @dev only clearingHouse can call this function\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from swapInput\n     * @param _baseAssetAmount base asset amount\n     * @param _quoteAssetAmountLimit limit of quote asset amount; for slippage protection\n     * @return quote asset amount\n     */\n    function swapOutput(\n        Dir _dirOfBase,\n        Decimal.decimal calldata _baseAssetAmount,\n        Decimal.decimal calldata _quoteAssetAmountLimit\n    )\n        external\n        override\n        onlyOpen\n        onlyCounterParty\n        returns (Decimal.decimal memory)\n    {\n        return\n            implSwapOutput(\n                _dirOfBase,\n                _baseAssetAmount,\n                _quoteAssetAmountLimit\n            );\n    }\n\n    /**\n     * @notice update funding rate\n     * @dev only allow to update while reaching `nextFundingTime`\n     * @return premiumFraction of this period in 18 digits\n     * @return markPrice of this period in 18 digits\n     * @return indexPrice of this period in 18 digits\n     */\n    function settleFunding()\n        external\n        override\n        onlyOpen\n        onlyCounterParty\n        returns (\n            SignedDecimal.signedDecimal memory premiumFraction,\n            Decimal.decimal memory markPrice,\n            Decimal.decimal memory indexPrice\n        )\n    {\n        require(block.timestamp >= nextFundingTime, \"settle funding too early\");\n\n        // premium = twapMarketPrice - twapIndexPrice\n        // timeFraction = fundingPeriod(1 hour) / 1 day\n        // premiumFraction = premium * timeFraction\n        markPrice = getTwapPrice(markPriceTwapInterval);\n        indexPrice = getIndexPrice();\n\n        SignedDecimal.signedDecimal memory premium = MixedDecimal\n            .fromDecimal(markPrice)\n            .subD(indexPrice);\n\n        premiumFraction = premium.mulScalar(fundingPeriod).divScalar(\n            int256(1 days)\n        );\n\n        // in order to prevent multiple funding settlement during very short time after network congestion\n        uint256 minNextValidFundingTime = block.timestamp + fundingBufferPeriod;\n\n        // floor((nextFundingTime + fundingPeriod) / 3600) * 3600\n        uint256 nextFundingTimeOnHourStart = ((nextFundingTime +\n            fundingPeriod) / 1 hours) * 1 hours;\n\n        // max(nextFundingTimeOnHourStart, minNextValidFundingTime)\n        nextFundingTime = nextFundingTimeOnHourStart > minNextValidFundingTime\n            ? nextFundingTimeOnHourStart\n            : minNextValidFundingTime;\n\n        // DEPRECATED only for backward compatibility before we upgrade ClearingHouse\n        // reset funding related states\n        baseAssetDeltaThisFundingPeriod = SignedDecimal.zero();\n    }\n\n    /**\n     * @notice repeg mark price to index price\n     * @dev only clearing house can call\n     */\n    function repegPrice()\n        external\n        override\n        onlyOpen\n        onlyCounterParty\n        returns (\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            SignedDecimal.signedDecimal memory\n        )\n    {\n        require(\n            block.timestamp >= lastRepegTimestamp + repegBufferPeriod,\n            \"repeg interval too small\"\n        );\n        Decimal.decimal memory indexPrice = getIndexPrice();\n\n        // calculation must be done before repeg\n        SignedDecimal.signedDecimal memory repegPnl = calcPriceRepegPnl(\n            indexPrice\n        );\n\n        // REPEG, y / x = price, y = price * x\n        Decimal.decimal memory quoteAssetReserveBefore = quoteAssetReserve;\n        quoteAssetReserve = indexPrice.mulD(baseAssetReserve);\n        k = quoteAssetReserve.mulD(baseAssetReserve);\n        lastRepegTimestamp = block.timestamp;\n\n        // update repeg checkpoints\n        _y0 = quoteAssetReserve;\n        _x0 = baseAssetReserve;\n\n        // add reserve snapshot, should be only after updating reserves\n        _addReserveSnapshot();\n\n        emit Repeg(\n            quoteAssetReserveBefore.toUint(),\n            baseAssetReserve.toUint(),\n            quoteAssetReserve.toUint(),\n            baseAssetReserve.toUint(),\n            repegPnl.toInt()\n        );\n        return (\n            quoteAssetReserveBefore,\n            baseAssetReserve,\n            quoteAssetReserve,\n            baseAssetReserve,\n            repegPnl\n        );\n    }\n\n    /**\n     * @notice adjust liquidity depth\n     * @dev only clearing house can call\n     */\n    function repegK(\n        Decimal.decimal memory _multiplier\n    )\n        external\n        override\n        onlyOpen\n        onlyCounterParty\n        returns (\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            SignedDecimal.signedDecimal memory\n        )\n    {\n        require(\n            block.timestamp >= lastRepegTimestamp + repegBufferPeriod,\n            \"repeg interval too small\"\n        );\n\n        Decimal.decimal memory multiplierSqrt = _multiplier.sqrt();\n\n        Decimal.decimal memory quoteAssetReserveBefore = quoteAssetReserve;\n        Decimal.decimal memory baseAssetReserveBefore = baseAssetReserve;\n\n        Decimal.decimal memory quoteAssetReserveAfter = quoteAssetReserveBefore\n            .mulD(multiplierSqrt);\n        Decimal.decimal memory baseAssetReserveAfter = baseAssetReserveBefore\n            .mulD(multiplierSqrt);\n        Decimal.decimal memory _k = quoteAssetReserveAfter.mulD(\n            baseAssetReserveAfter\n        );\n\n        // calculation must be done before repeg\n        SignedDecimal.signedDecimal memory repegPnl = calcKRepegPnl(_k);\n\n        // REPEG\n        quoteAssetReserve = quoteAssetReserveAfter;\n        baseAssetReserve = baseAssetReserveAfter;\n        k = _k;\n        lastRepegTimestamp = block.timestamp;\n\n        // update repeg checkpoints\n        _y0 = quoteAssetReserveAfter;\n        _x0 = baseAssetReserveAfter;\n\n        // add reserve snapshot, should be only after updating reserves\n        _addReserveSnapshot();\n\n        emit Repeg(\n            quoteAssetReserveBefore.toUint(),\n            baseAssetReserveBefore.toUint(),\n            quoteAssetReserveAfter.toUint(),\n            baseAssetReserveAfter.toUint(),\n            repegPnl.toInt()\n        );\n\n        return (\n            quoteAssetReserveBefore,\n            baseAssetReserveBefore,\n            quoteAssetReserveAfter,\n            baseAssetReserveAfter,\n            repegPnl\n        );\n    }\n\n    // update funding rate = premiumFraction / twapIndexPrice\n    function updateFundingRate(\n        SignedDecimal.signedDecimal memory _premiumFractionLong,\n        SignedDecimal.signedDecimal memory _premiumFractionShort,\n        Decimal.decimal memory _underlyingPrice\n    ) external override onlyOpen onlyCounterParty {\n        fundingRate.fundingRateLong = _premiumFractionLong.divD(\n            _underlyingPrice\n        );\n        fundingRate.fundingRateShort = _premiumFractionShort.divD(\n            _underlyingPrice\n        );\n        emit FundingRateUpdated(\n            fundingRate.fundingRateLong.toInt(),\n            fundingRate.fundingRateShort.toInt(),\n            _underlyingPrice.toUint()\n        );\n    }\n\n    /**\n     * @notice set counter party\n     * @dev only owner can call this function\n     * @param _counterParty address of counter party\n     */\n    function setCounterParty(address _counterParty) external onlyOwner {\n        counterParty = _counterParty;\n    }\n\n    /**\n     * @notice set `open` flag. Amm is open to trade if `open` is true. Default is false.\n     * @dev only owner can call this function\n     * @param _open open to trade is true, otherwise is false.\n     */\n    function setOpen(bool _open) external onlyOwner {\n        if (open == _open) return;\n\n        open = _open;\n        if (_open) {\n            nextFundingTime =\n                ((block.timestamp + fundingPeriod) / 1 hours) *\n                1 hours;\n        }\n        emit Open(_open);\n    }\n\n    /**\n     * @notice set new fee ratio\n     * @dev only owner can call\n     * @param _feeRatio new ratio\n     */\n    function setFeeRatio(Decimal.decimal memory _feeRatio) external onlyOwner {\n        feeRatio = _feeRatio;\n        emit FeeRatioChanged(feeRatio.toUint());\n    }\n\n    /**\n     * @notice set new trade limit ratio\n     * @dev only owner\n     * @param _tradeLimitRatio new ratio\n     */\n    function setTradeLimitRatio(\n        Decimal.decimal memory _tradeLimitRatio\n    ) external onlyOwner {\n        _requireValidRatio(_tradeLimitRatio);\n        tradeLimitRatio = _tradeLimitRatio;\n        emit TradeLimitRatioChanged(tradeLimitRatio.toUint());\n    }\n\n    /**\n     * @notice set fluctuation limit rate. Default value is `1 / max leverage`\n     * @dev only owner can call this function\n     * @param _fluctuationLimitRatio fluctuation limit rate in 18 digits, 0 means skip the checking\n     */\n    function setFluctuationLimitRatio(\n        Decimal.decimal memory _fluctuationLimitRatio\n    ) external onlyOwner {\n        fluctuationLimitRatio = _fluctuationLimitRatio;\n        emit FluctuationLimitRatioChanged(fluctuationLimitRatio.toUint());\n    }\n\n    /**\n     * @notice set init margin ratio\n     * @dev only owner can call\n     * @param _initMarginRatio new maintenance margin ratio in 18 digits\n     */\n    function setInitMarginRatio(\n        Decimal.decimal memory _initMarginRatio\n    ) external onlyOwner {\n        _requireValidRatio(_initMarginRatio);\n        initMarginRatio = _initMarginRatio;\n        emit InitMarginRatioChanged(initMarginRatio.toUint());\n    }\n\n    /**\n     * @notice set maintenance margin ratio\n     * @dev only owner can call\n     * @param _maintenanceMarginRatio new maintenance margin ratio in 18 digits\n     */\n    function setMaintenanceMarginRatio(\n        Decimal.decimal memory _maintenanceMarginRatio\n    ) external onlyOwner {\n        _requireValidRatio(_maintenanceMarginRatio);\n        maintenanceMarginRatio = _maintenanceMarginRatio;\n        emit MaintenanceMarginRatioChanged(maintenanceMarginRatio.toUint());\n    }\n\n    /**\n     * @notice set the margin ratio after deleveraging\n     * @dev only owner can call\n     * @param _partialLiquidationRatio new ratio\n     */\n    function setPartialLiquidationRatio(\n        Decimal.decimal memory _partialLiquidationRatio\n    ) external onlyOwner {\n        _requireValidRatio(_partialLiquidationRatio);\n        // solhint-disable-next-line reason-string\n        require(\n            _partialLiquidationRatio.cmp(Decimal.one()) < 0,\n            \"partial liq ratio should be less than 1\"\n        );\n        partialLiquidationRatio = _partialLiquidationRatio;\n        emit PartialLiquidationRatioChanged(partialLiquidationRatio.toUint());\n    }\n\n    /**\n     * @notice set liquidation fee ratio\n     * @dev if margin ratio falls below liquidation fee ratio, entire position is liquidated\n     * @dev only owner can call\n     * @param _liquidationFeeRatio new ratio\n     */\n    function setLiquidationFeeRatio(\n        Decimal.decimal memory _liquidationFeeRatio\n    ) external onlyOwner {\n        _requireValidRatio(_liquidationFeeRatio);\n        liquidationFeeRatio = _liquidationFeeRatio;\n        emit LiquidationFeeRatioChanged(liquidationFeeRatio.toUint());\n    }\n\n    /**\n     * Set level 1 dynamic fee settings\n     * only owner\n     * @dev set threshold as 0 to disable\n     */\n    function setLevel1DynamicFeeSettings(\n        Decimal.decimal memory _divergenceThresholdRatio,\n        Decimal.decimal memory _feeRatio,\n        Decimal.decimal memory _feeInFavorRatio\n    ) external onlyOwner {\n        level1DynamicFeeSettings = DynamicFeeSettings(\n            _divergenceThresholdRatio,\n            _feeRatio,\n            _feeInFavorRatio\n        );\n        emit Level1DynamicFeeSettingsChanged(\n            _divergenceThresholdRatio.toUint(),\n            _feeRatio.toUint(),\n            _feeInFavorRatio.toUint()\n        );\n    }\n\n    /**\n     * Set level 2 dynamic fee settings\n     * only owner\n     * @dev set threshold as 0 to disable\n     */\n    function setLevel2DynamicFeeSettings(\n        Decimal.decimal memory _divergenceThresholdRatio,\n        Decimal.decimal memory _feeRatio,\n        Decimal.decimal memory _feeInFavorRatio\n    ) external onlyOwner {\n        level2DynamicFeeSettings = DynamicFeeSettings(\n            _divergenceThresholdRatio,\n            _feeRatio,\n            _feeInFavorRatio\n        );\n        emit Level2DynamicFeeSettingsChanged(\n            _divergenceThresholdRatio.toUint(),\n            _feeRatio.toUint(),\n            _feeInFavorRatio.toUint()\n        );\n    }\n\n    /**\n     * @notice set new cap during guarded period, which is max position size that traders can hold\n     * @dev only owner can call. assume this will be removes soon once the guarded period has ended. must be set before opening amm\n     * @param _maxHoldingBaseAsset max position size that traders can hold in 18 digits\n     * @param _openInterestNotionalCap open interest cap, denominated in quoteToken\n     */\n    function setCap(\n        Decimal.decimal memory _maxHoldingBaseAsset,\n        Decimal.decimal memory _openInterestNotionalCap\n    ) external onlyOwner {\n        maxHoldingBaseAsset = _maxHoldingBaseAsset;\n        openInterestNotionalCap = _openInterestNotionalCap;\n        emit CapChanged(\n            maxHoldingBaseAsset.toUint(),\n            openInterestNotionalCap.toUint()\n        );\n    }\n\n    /**\n     * @notice set funding period\n     * @dev only owner\n     * @param _fundingPeriod new funding period\n     */\n    function setFundingPeriod(uint256 _fundingPeriod) external onlyOwner {\n        fundingPeriod = _fundingPeriod;\n        fundingBufferPeriod = _fundingPeriod / 2;\n        emit FundingPeriodChanged(_fundingPeriod);\n    }\n\n    /**\n     * @notice set repeg buffer period\n     * @dev only owner\n     * @param _repegBufferPeriod new repeg buffer period\n     */\n    function setRepegBufferPeriod(\n        uint256 _repegBufferPeriod\n    ) external onlyOwner {\n        repegBufferPeriod = _repegBufferPeriod;\n    }\n\n    /**\n     * @notice set time interval for twap calculation, default is 1 hour\n     * @dev only owner can call this function\n     * @param _interval time interval in seconds\n     */\n    function setMarkPriceTwapInterval(uint256 _interval) external onlyOwner {\n        require(_interval != 0, \"can not set interval to 0\");\n        markPriceTwapInterval = _interval;\n    }\n\n    /**\n     * @notice set priceFeed address\n     * @dev only owner can call\n     * @param _priceFeed new price feed for this AMM\n     */\n    function setPriceFeed(IPriceFeed _priceFeed) external onlyOwner {\n        require(address(_priceFeed) != address(0), \"invalid PriceFeed address\");\n        priceFeed = _priceFeed;\n        emit PriceFeedUpdated(address(priceFeed));\n    }\n\n    /**\n     * @notice dynamic fee mechanism (only on open position, not on close)\n     * - if trade leaves mark price to be within 2.5% range of index price, then fee percent = 0.3% (standard)\n     * - if trade leaves mark price to be over 2.5% range of index price, then fee percent = 1% (surged)\n     * - if trade leaves mark price to be over 5.0% range of index price, then fee percent = 5% (surged)\n     * - this ensures that traders act towards maintaining peg\n     * @notice calculate fees to be levied on the trade\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short\n     * @param _quoteAssetAmount quoteAssetAmount\n     * @param _isOpenPos whether is opening a new position\n     * @return fees fees to be levied on trade\n     */\n    function calcFee(\n        Dir _dirOfQuote,\n        Decimal.decimal calldata _quoteAssetAmount,\n        bool _isOpenPos\n    ) external view override returns (Decimal.decimal memory fees) {\n        if (_quoteAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n        Decimal.decimal memory indexPrice = getIndexPrice();\n        Decimal.decimal memory markPrice = getMarkPrice();\n\n        uint256 divergenceRatio = MixedDecimal\n            .fromDecimal(indexPrice)\n            .subD(markPrice)\n            .abs()\n            .divD(indexPrice)\n            .toUint();\n\n        bool isConvergingTrade = (\n            markPrice.toUint() < indexPrice.toUint()\n                ? Dir.ADD_TO_AMM\n                : Dir.REMOVE_FROM_AMM\n        ) == _dirOfQuote;\n\n        Decimal.decimal memory _feeRatio = feeRatio;\n\n        // implying surge fee pricing only on open position\n        if (_isOpenPos) {\n            if (\n                level2DynamicFeeSettings.divergenceThresholdRatio.toUint() !=\n                0 && // 0 means unset/disabled\n                divergenceRatio >\n                level2DynamicFeeSettings.divergenceThresholdRatio.toUint()\n            ) {\n                if (isConvergingTrade)\n                    _feeRatio = level2DynamicFeeSettings.feeInFavorRatio;\n                else _feeRatio = level2DynamicFeeSettings.feeRatio;\n            } else if (\n                level1DynamicFeeSettings.divergenceThresholdRatio.toUint() !=\n                0 &&\n                divergenceRatio >\n                level1DynamicFeeSettings.divergenceThresholdRatio.toUint()\n            ) {\n                if (isConvergingTrade)\n                    _feeRatio = level1DynamicFeeSettings.feeInFavorRatio;\n                else _feeRatio = level1DynamicFeeSettings.feeRatio;\n            }\n        }\n        fees = _quoteAssetAmount.mulD(_feeRatio);\n    }\n\n    /**\n     * @notice get input twap amount.\n     * returns how many base asset you will get with the input quote amount based on twap price.\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short.\n     * @param _quoteAssetAmount quote asset amount\n     * @return base asset amount\n     */\n    function getInputTwap(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _quoteAssetAmount\n    ) external view override returns (Decimal.decimal memory) {\n        return\n            _implGetInputAssetTwapPrice(\n                _dirOfQuote,\n                _quoteAssetAmount,\n                QuoteAssetDir.QUOTE_IN,\n                15 minutes\n            );\n    }\n\n    /**\n     * @notice calculate repeg pnl\n     * @param _repegTo price to repeg to\n     * @return repegPnl total pnl incurred on vault positions after repeg\n     */\n    function calcPriceRepegPnl(\n        Decimal.decimal memory _repegTo\n    ) public view returns (SignedDecimal.signedDecimal memory repegPnl) {\n        SignedDecimal.signedDecimal memory y0 = MixedDecimal.fromDecimal(_y0);\n        SignedDecimal.signedDecimal memory x0 = MixedDecimal.fromDecimal(_x0);\n        SignedDecimal.signedDecimal memory p0 = y0.divD(x0);\n        SignedDecimal.signedDecimal memory p1 = MixedDecimal.fromDecimal(\n            getMarkPrice()\n        );\n        SignedDecimal.signedDecimal memory p2 = MixedDecimal.fromDecimal(\n            _repegTo\n        );\n        repegPnl = y0.mulD(\n            p2\n                .divD(p1)\n                .addD(p1.divD(p0).sqrt())\n                .subD(p2.divD(p1.mulD(p0).sqrt()))\n                .subD(Decimal.one())\n        );\n    }\n\n    function calcKRepegPnl(\n        Decimal.decimal memory _k\n    ) public view returns (SignedDecimal.signedDecimal memory repegPnl) {\n        SignedDecimal.signedDecimal memory x0 = MixedDecimal.fromDecimal(_x0);\n        SignedDecimal.signedDecimal memory y0 = MixedDecimal.fromDecimal(_y0);\n        SignedDecimal.signedDecimal memory p0 = y0.divD(x0);\n        SignedDecimal.signedDecimal memory k0 = y0.mulD(x0);\n        SignedDecimal.signedDecimal memory p1 = MixedDecimal.fromDecimal(\n            getMarkPrice()\n        );\n        SignedDecimal.signedDecimal memory k1 = MixedDecimal.fromDecimal(_k);\n        SignedDecimal.signedDecimal memory firstDenom = k1\n            .divD(p1)\n            .sqrt()\n            .subD(k0.divD(p1).sqrt())\n            .addD(k0.divD(p0).sqrt());\n        repegPnl = k1\n            .divD(firstDenom)\n            .subD(k1.mulD(p1).sqrt())\n            .subD(k0.mulD(p0).sqrt())\n            .addD(k0.mulD(p1).sqrt());\n    }\n\n    /**\n     * @notice get output twap amount.\n     * return how many quote asset you will get with the input base amount on twap price.\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from `getInputTwap`.\n     * @param _baseAssetAmount base asset amount\n     * @return quote asset amount\n     */\n    function getOutputTwap(\n        Dir _dirOfBase,\n        Decimal.decimal memory _baseAssetAmount\n    ) external view override returns (Decimal.decimal memory) {\n        return\n            _implGetInputAssetTwapPrice(\n                _dirOfBase,\n                _baseAssetAmount,\n                QuoteAssetDir.QUOTE_OUT,\n                15 minutes\n            );\n    }\n\n    /**\n     * @notice check if close trade goes over fluctuation limit\n     * @param _dirOfBase ADD_TO_AMM for closing long, REMOVE_FROM_AMM for closing short\n     */\n    function isOverFluctuationLimit(\n        Dir _dirOfBase,\n        Decimal.decimal memory _baseAssetAmount\n    ) external view override returns (bool) {\n        // Skip the check if the limit is 0\n        if (fluctuationLimitRatio.toUint() == 0) {\n            return false;\n        }\n\n        (\n            Decimal.decimal memory upperLimit,\n            Decimal.decimal memory lowerLimit\n        ) = _getPriceBoundariesOfLastBlock();\n\n        Decimal.decimal memory quoteAssetExchanged = getOutputPrice(\n            _dirOfBase,\n            _baseAssetAmount\n        );\n        Decimal.decimal memory price = (_dirOfBase == Dir.REMOVE_FROM_AMM)\n            ? quoteAssetReserve.addD(quoteAssetExchanged).divD(\n                baseAssetReserve.subD(_baseAssetAmount)\n            )\n            : quoteAssetReserve.subD(quoteAssetExchanged).divD(\n                baseAssetReserve.addD(_baseAssetAmount)\n            );\n\n        if (price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0) {\n            return false;\n        }\n        return true;\n    }\n\n    function isOverSpreadLimit() external view override returns (bool) {\n        Decimal.decimal memory oraclePrice = getIndexPrice();\n        require(oraclePrice.toUint() > 0, \"index price is 0\");\n        Decimal.decimal memory marketPrice = getMarkPrice();\n        Decimal.decimal memory oracleSpreadRatioAbs = MixedDecimal\n            .fromDecimal(marketPrice)\n            .subD(oraclePrice)\n            .divD(oraclePrice)\n            .abs();\n        // TODO move to variable\n        return oracleSpreadRatioAbs.toUint() >= 1e17; // 10%\n    }\n\n    function getSnapshotLen() external view returns (uint256) {\n        return reserveSnapshots.length;\n    }\n\n    function getFeeRatio()\n        external\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return feeRatio;\n    }\n\n    function getInitMarginRatio()\n        external\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return initMarginRatio;\n    }\n\n    function getMaintenanceMarginRatio()\n        external\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return maintenanceMarginRatio;\n    }\n\n    function getPartialLiquidationRatio()\n        external\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return partialLiquidationRatio;\n    }\n\n    function getLiquidationFeeRatio()\n        external\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return liquidationFeeRatio;\n    }\n\n    /**\n     * too avoid too many ratio calls in clearing house\n     */\n    function getRatios() external view override returns (Ratios memory) {\n        return\n            Ratios(\n                feeRatio,\n                initMarginRatio,\n                maintenanceMarginRatio,\n                partialLiquidationRatio,\n                liquidationFeeRatio\n            );\n    }\n\n    /**\n     * @notice get current quote/base asset reserve.\n     * @return (quote asset reserve, base asset reserve)\n     */\n    function getReserves()\n        external\n        view\n        returns (Decimal.decimal memory, Decimal.decimal memory)\n    {\n        return (quoteAssetReserve, baseAssetReserve);\n    }\n\n    function getMaxHoldingBaseAsset()\n        external\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return maxHoldingBaseAsset;\n    }\n\n    function getOpenInterestNotionalCap()\n        external\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return openInterestNotionalCap;\n    }\n\n    function getBaseAssetDelta()\n        external\n        view\n        override\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        return totalPositionSize;\n    }\n\n    function getCumulativeNotional()\n        external\n        view\n        override\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        return cumulativeNotional;\n    }\n\n    //\n    // PUBLIC\n    //\n\n    /**\n     * @notice get input amount. returns how many base asset you will get with the input quote amount.\n     * @param _dirOfQuote ADD_TO_AMM for long, REMOVE_FROM_AMM for short.\n     * @param _quoteAssetAmount quote asset amount\n     * @return base asset amount\n     */\n    function getInputPrice(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _quoteAssetAmount\n    ) public view override returns (Decimal.decimal memory) {\n        return\n            getInputPriceWithReserves(\n                _dirOfQuote,\n                _quoteAssetAmount,\n                quoteAssetReserve,\n                baseAssetReserve\n            );\n    }\n\n    /**\n     * @notice get output price. return how many quote asset you will get with the input base amount\n     * @param _dirOfBase ADD_TO_AMM for short, REMOVE_FROM_AMM for long, opposite direction from `getInput`.\n     * @param _baseAssetAmount base asset amount\n     * @return quote asset amount\n     */\n    function getOutputPrice(\n        Dir _dirOfBase,\n        Decimal.decimal memory _baseAssetAmount\n    ) public view override returns (Decimal.decimal memory) {\n        return\n            getOutputPriceWithReserves(\n                _dirOfBase,\n                _baseAssetAmount,\n                quoteAssetReserve,\n                baseAssetReserve\n            );\n    }\n\n    /**\n     * @notice get mark price based on current quote/base asset reserve.\n     * @return mark price\n     */\n    function getMarkPrice()\n        public\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return quoteAssetReserve.divD(baseAssetReserve);\n    }\n\n    /**\n     * @notice get index price provided by oracle\n     * @return index price\n     */\n    function getIndexPrice()\n        public\n        view\n        override\n        returns (Decimal.decimal memory)\n    {\n        return Decimal.decimal(priceFeed.getPrice(priceFeedKey));\n    }\n\n    /**\n     * @notice get twap price\n     */\n    function getTwapPrice(\n        uint256 _intervalInSeconds\n    ) public view returns (Decimal.decimal memory) {\n        return _implGetReserveTwapPrice(_intervalInSeconds);\n    }\n\n    /*       plus/minus 1 while the amount is not dividable\n     *\n     *        getInputPrice                         getOutputPrice\n     *\n     *           (amount - 1)              (amount + 1)   \n     *                                           |             \n     *        ------->  |                           <--------  \n     *    -------      -------                   -------        -------\n     *    |  Q  |      |  B  |                   |  Q  |        |  B  |\n     *    -------      -------                   -------        -------\n     *        ------->                           |  <--------  \n     *                  |                                      \n     *     (amount + 1)              (amount + 1)      \n     **/\n\n    function getInputPriceWithReserves(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) public view override returns (Decimal.decimal memory) {\n        if (_quoteAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n\n        bool isAddToAmm = _dirOfQuote == Dir.ADD_TO_AMM;\n\n        SignedDecimal.signedDecimal memory baseAssetAfter;\n        Decimal.decimal memory quoteAssetAfter;\n        Decimal.decimal memory baseAssetBought;\n\n        if (isAddToAmm) {\n            quoteAssetAfter = _quoteAssetPoolAmount.addD(_quoteAssetAmount);\n        } else {\n            quoteAssetAfter = _quoteAssetPoolAmount.subD(_quoteAssetAmount);\n        }\n        require(quoteAssetAfter.toUint() != 0, \"quote asset after is 0\");\n\n        baseAssetAfter = MixedDecimal.fromDecimal(k).divD(quoteAssetAfter);\n        baseAssetBought = baseAssetAfter.subD(_baseAssetPoolAmount).abs();\n\n        return baseAssetBought;\n    }\n\n    function getOutputPriceWithReserves(\n        Dir _dirOfBase,\n        Decimal.decimal memory _baseAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) public view override returns (Decimal.decimal memory) {\n        if (_baseAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n\n        bool isAddToAmm = _dirOfBase == Dir.ADD_TO_AMM;\n\n        SignedDecimal.signedDecimal memory quoteAssetAfter;\n        Decimal.decimal memory baseAssetAfter;\n        Decimal.decimal memory quoteAssetSold;\n\n        if (isAddToAmm) {\n            baseAssetAfter = _baseAssetPoolAmount.addD(_baseAssetAmount);\n        } else {\n            baseAssetAfter = _baseAssetPoolAmount.subD(_baseAssetAmount);\n        }\n        require(baseAssetAfter.toUint() != 0, \"base asset after is 0\");\n\n        quoteAssetAfter = MixedDecimal.fromDecimal(k).divD(baseAssetAfter);\n        quoteAssetSold = quoteAssetAfter.subD(_quoteAssetPoolAmount).abs();\n\n        return quoteAssetSold;\n    }\n\n    //\n    // INTERNAL\n    //\n\n    function _addReserveSnapshot() internal {\n        uint256 currentBlock = block.number;\n        ReserveSnapshot storage latestSnapshot = reserveSnapshots[\n            reserveSnapshots.length - 1\n        ];\n        // update values in snapshot if in the same block\n        if (currentBlock == latestSnapshot.blockNumber) {\n            latestSnapshot.quoteAssetReserve = quoteAssetReserve;\n            latestSnapshot.baseAssetReserve = baseAssetReserve;\n        } else {\n            reserveSnapshots.push(\n                ReserveSnapshot(\n                    quoteAssetReserve,\n                    baseAssetReserve,\n                    block.timestamp,\n                    currentBlock\n                )\n            );\n        }\n        emit ReserveSnapshotted(\n            quoteAssetReserve.toUint(),\n            baseAssetReserve.toUint(),\n            block.timestamp\n        );\n    }\n\n    function implSwapOutput(\n        Dir _dirOfBase,\n        Decimal.decimal memory _baseAssetAmount,\n        Decimal.decimal memory _quoteAssetAmountLimit\n    ) internal returns (Decimal.decimal memory) {\n        if (_baseAssetAmount.toUint() == 0) {\n            return Decimal.zero();\n        }\n        if (_dirOfBase == Dir.REMOVE_FROM_AMM) {\n            require(\n                baseAssetReserve.mulD(tradeLimitRatio).toUint() >=\n                    _baseAssetAmount.toUint(),\n                \"over trading limit\"\n            );\n        }\n\n        Decimal.decimal memory quoteAssetAmount = getOutputPrice(\n            _dirOfBase,\n            _baseAssetAmount\n        );\n        Dir dirOfQuote = _dirOfBase == Dir.ADD_TO_AMM\n            ? Dir.REMOVE_FROM_AMM\n            : Dir.ADD_TO_AMM;\n        // If SHORT, exchanged quote amount should be less than _quoteAssetAmountLimit,\n        // otherwise(LONG), exchanged base amount should be more than _quoteAssetAmountLimit.\n        // In the SHORT case, more quote assets means more payment so should not be more than _quoteAssetAmountLimit\n        if (_quoteAssetAmountLimit.toUint() != 0) {\n            if (dirOfQuote == Dir.REMOVE_FROM_AMM) {\n                // SHORT\n                require(\n                    quoteAssetAmount.toUint() >=\n                        _quoteAssetAmountLimit.toUint(),\n                    \"Less than minimal quote token\"\n                );\n            } else {\n                // LONG\n                require(\n                    quoteAssetAmount.toUint() <=\n                        _quoteAssetAmountLimit.toUint(),\n                    \"More than maximal quote token\"\n                );\n            }\n        }\n\n        // as mentioned in swapOutput(), it always allows going over fluctuation limit because\n        // it is only used by close/liquidate positions\n        _updateReserve(dirOfQuote, quoteAssetAmount, _baseAssetAmount, true);\n        emit SwapOutput(\n            _dirOfBase,\n            quoteAssetAmount.toUint(),\n            _baseAssetAmount.toUint()\n        );\n        return quoteAssetAmount;\n    }\n\n    // the direction is in quote asset\n    function _updateReserve(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _baseAssetAmount,\n        bool _canOverFluctuationLimit\n    ) internal {\n        // check if it's over fluctuationLimitRatio\n        // this check should be before reserves being updated\n        _checkIsOverBlockFluctuationLimit(\n            _dirOfQuote,\n            _quoteAssetAmount,\n            _baseAssetAmount,\n            _canOverFluctuationLimit\n        );\n\n        if (_dirOfQuote == Dir.ADD_TO_AMM) {\n            quoteAssetReserve = quoteAssetReserve.addD(_quoteAssetAmount);\n            baseAssetReserve = baseAssetReserve.subD(_baseAssetAmount);\n            baseAssetDeltaThisFundingPeriod = baseAssetDeltaThisFundingPeriod\n                .subD(_baseAssetAmount);\n            totalPositionSize = totalPositionSize.addD(_baseAssetAmount);\n            cumulativeNotional = cumulativeNotional.addD(_quoteAssetAmount);\n        } else {\n            quoteAssetReserve = quoteAssetReserve.subD(_quoteAssetAmount);\n            baseAssetReserve = baseAssetReserve.addD(_baseAssetAmount);\n            baseAssetDeltaThisFundingPeriod = baseAssetDeltaThisFundingPeriod\n                .addD(_baseAssetAmount);\n            totalPositionSize = totalPositionSize.subD(_baseAssetAmount);\n            cumulativeNotional = cumulativeNotional.subD(_quoteAssetAmount);\n        }\n\n        // _addReserveSnapshot must be after checking price fluctuation\n        _addReserveSnapshot();\n    }\n\n    function _implGetInputAssetTwapPrice(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _assetAmount,\n        QuoteAssetDir _inOut,\n        uint256 _interval\n    ) internal view returns (Decimal.decimal memory) {\n        TwapPriceCalcParams memory params;\n        params.opt = TwapCalcOption.INPUT_ASSET;\n        params.snapshotIndex = reserveSnapshots.length - 1;\n        params.asset.dir = _dirOfQuote;\n        params.asset.assetAmount = _assetAmount;\n        params.asset.inOrOut = _inOut;\n        return _calcTwap(params, _interval);\n    }\n\n    function _implGetReserveTwapPrice(\n        uint256 _interval\n    ) internal view returns (Decimal.decimal memory) {\n        TwapPriceCalcParams memory params;\n        params.opt = TwapCalcOption.RESERVE_ASSET;\n        params.snapshotIndex = reserveSnapshots.length - 1;\n        return _calcTwap(params, _interval);\n    }\n\n    function _calcTwap(\n        TwapPriceCalcParams memory _params,\n        uint256 _interval\n    ) internal view returns (Decimal.decimal memory) {\n        Decimal.decimal memory currentPrice = _getPriceWithSpecificSnapshot(\n            _params\n        );\n        if (_interval == 0) {\n            return currentPrice;\n        }\n\n        uint256 baseTimestamp = block.timestamp - _interval;\n        ReserveSnapshot memory currentSnapshot = reserveSnapshots[\n            _params.snapshotIndex\n        ];\n        // return the latest snapshot price directly\n        // if only one snapshot or the timestamp of latest snapshot is earlier than asking for\n        if (\n            reserveSnapshots.length == 1 ||\n            currentSnapshot.timestamp <= baseTimestamp\n        ) {\n            return currentPrice;\n        }\n\n        uint256 previousTimestamp = currentSnapshot.timestamp;\n        uint256 period = block.timestamp - previousTimestamp;\n        Decimal.decimal memory weightedPrice = currentPrice.mulScalar(period);\n        while (true) {\n            // if snapshot history is too short\n            if (_params.snapshotIndex == 0) {\n                return weightedPrice.divScalar(period);\n            }\n\n            _params.snapshotIndex = _params.snapshotIndex - 1;\n            currentSnapshot = reserveSnapshots[_params.snapshotIndex];\n            currentPrice = _getPriceWithSpecificSnapshot(_params);\n\n            // check if current round timestamp is earlier than target timestamp\n            if (currentSnapshot.timestamp <= baseTimestamp) {\n                // weighted time period will be (target timestamp - previous timestamp). For example,\n                // now is 1000, _interval is 100, then target timestamp is 900. If timestamp of current round is 970,\n                // and timestamp of NEXT round is 880, then the weighted time period will be (970 - 900) = 70,\n                // instead of (970 - 880)\n                weightedPrice = weightedPrice.addD(\n                    currentPrice.mulScalar(previousTimestamp - baseTimestamp)\n                );\n                break;\n            }\n\n            uint256 timeFraction = previousTimestamp -\n                currentSnapshot.timestamp;\n            weightedPrice = weightedPrice.addD(\n                currentPrice.mulScalar(timeFraction)\n            );\n            period = period + timeFraction;\n            previousTimestamp = currentSnapshot.timestamp;\n        }\n        return weightedPrice.divScalar(_interval);\n    }\n\n    function _getPriceWithSpecificSnapshot(\n        TwapPriceCalcParams memory params\n    ) internal view virtual returns (Decimal.decimal memory) {\n        ReserveSnapshot memory snapshot = reserveSnapshots[\n            params.snapshotIndex\n        ];\n\n        // RESERVE_ASSET means price comes from quoteAssetReserve/baseAssetReserve\n        // INPUT_ASSET means getInput/Output price with snapshot's reserve\n        if (params.opt == TwapCalcOption.RESERVE_ASSET) {\n            return snapshot.quoteAssetReserve.divD(snapshot.baseAssetReserve);\n        } else if (params.opt == TwapCalcOption.INPUT_ASSET) {\n            if (params.asset.assetAmount.toUint() == 0) {\n                return Decimal.zero();\n            }\n            if (params.asset.inOrOut == QuoteAssetDir.QUOTE_IN) {\n                return\n                    getInputPriceWithReserves(\n                        params.asset.dir,\n                        params.asset.assetAmount,\n                        snapshot.quoteAssetReserve,\n                        snapshot.baseAssetReserve\n                    );\n            } else if (params.asset.inOrOut == QuoteAssetDir.QUOTE_OUT) {\n                return\n                    getOutputPriceWithReserves(\n                        params.asset.dir,\n                        params.asset.assetAmount,\n                        snapshot.quoteAssetReserve,\n                        snapshot.baseAssetReserve\n                    );\n            }\n        }\n        revert(\"not supported option\");\n    }\n\n    function _getPriceBoundariesOfLastBlock()\n        internal\n        view\n        returns (Decimal.decimal memory, Decimal.decimal memory)\n    {\n        uint256 len = reserveSnapshots.length;\n        ReserveSnapshot memory latestSnapshot = reserveSnapshots[len - 1];\n        // if the latest snapshot is the same as current block, get the previous one\n        if (latestSnapshot.blockNumber == block.number && len > 1) {\n            latestSnapshot = reserveSnapshots[len - 2];\n        }\n\n        Decimal.decimal memory lastPrice = latestSnapshot\n            .quoteAssetReserve\n            .divD(latestSnapshot.baseAssetReserve);\n        Decimal.decimal memory upperLimit = lastPrice.mulD(\n            Decimal.one().addD(fluctuationLimitRatio)\n        );\n        Decimal.decimal memory lowerLimit = lastPrice.mulD(\n            Decimal.one().subD(fluctuationLimitRatio)\n        );\n        return (upperLimit, lowerLimit);\n    }\n\n    /**\n     * @notice there can only be one tx in a block can skip the fluctuation check\n     *         otherwise, some positions can never be closed or liquidated\n     * @param _canOverFluctuationLimit if true, can skip fluctuation check for once; else, can never skip\n     */\n    function _checkIsOverBlockFluctuationLimit(\n        Dir _dirOfQuote,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _baseAssetAmount,\n        bool _canOverFluctuationLimit\n    ) internal view {\n        // Skip the check if the limit is 0\n        if (fluctuationLimitRatio.toUint() == 0) {\n            return;\n        }\n\n        //\n        // assume the price of the last block is 10, fluctuation limit ratio is 5%, then\n        //\n        //          current price\n        //  --+---------+-----------+---\n        //   9.5        10         10.5\n        // lower limit           upper limit\n        //\n        // when `openPosition`, the price can only be between 9.5 - 10.5\n        // when `liquidate` and `closePosition`, the price can exceed the boundary once\n        // (either lower than 9.5 or higher than 10.5)\n        // once it exceeds the boundary, all the rest txs in this block fail\n        //\n\n        (\n            Decimal.decimal memory upperLimit,\n            Decimal.decimal memory lowerLimit\n        ) = _getPriceBoundariesOfLastBlock();\n\n        Decimal.decimal memory price = quoteAssetReserve.divD(baseAssetReserve);\n        // solhint-disable-next-line reason-string\n        require(\n            price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0,\n            \"price is already over fluctuation limit\"\n        );\n\n        if (!_canOverFluctuationLimit) {\n            price = (_dirOfQuote == Dir.ADD_TO_AMM)\n                ? quoteAssetReserve.addD(_quoteAssetAmount).divD(\n                    baseAssetReserve.subD(_baseAssetAmount)\n                )\n                : quoteAssetReserve.subD(_quoteAssetAmount).divD(\n                    baseAssetReserve.addD(_baseAssetAmount)\n                );\n            require(\n                price.cmp(upperLimit) <= 0 && price.cmp(lowerLimit) >= 0,\n                \"price is over fluctuation limit\"\n            );\n        }\n    }\n\n    function _requireValidRatio(Decimal.decimal memory _ratio) internal pure {\n        require(_ratio.cmp(Decimal.one()) <= 0, \"invalid ratio\");\n    }\n}\n"
    },
    "contracts/ChainlinkPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@chainlink/contracts/src/v0.8/ChainlinkClient.sol\";\nimport \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\";\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport {IPriceFeed} from \"./interfaces/IPriceFeed.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Decimal} from \"./utils/Decimal.sol\";\nimport {BlockContext} from \"./utils/BlockContext.sol\";\n\ncontract ChainlinkPriceFeed is IPriceFeed, OwnableUpgradeable, BlockContext {\n    using SafeMath for uint256;\n\n    uint256 private constant TOKEN_DIGIT = 10 ** 18;\n\n    //**********************************************************//\n    //    The below state variables can not change the order    //\n    //**********************************************************//\n\n    // key by currency symbol, eg ETH\n    mapping(bytes32 => AggregatorV3Interface) public priceFeedMap;\n    bytes32[] public priceFeedKeys;\n    mapping(bytes32 => uint8) public priceFeedDecimalMap;\n    //**********************************************************//\n    //    The above state variables can not change the order    //\n    //**********************************************************//\n\n    // add state variables below //\n\n    // add state variables above //\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n    function initialize() public initializer {\n        __Ownable_init();\n    }\n\n    function addAggregator(\n        bytes32 _priceFeedKey,\n        address _aggregator\n    ) external onlyOwner {\n        requireNonEmptyAddress(_aggregator);\n        if (address(priceFeedMap[_priceFeedKey]) == address(0)) {\n            priceFeedKeys.push(_priceFeedKey);\n        }\n        priceFeedMap[_priceFeedKey] = AggregatorV3Interface(_aggregator);\n        priceFeedDecimalMap[_priceFeedKey] = AggregatorV3Interface(_aggregator)\n            .decimals();\n    }\n\n    function removeAggregator(bytes32 _priceFeedKey) external onlyOwner {\n        requireNonEmptyAddress(address(getAggregator(_priceFeedKey)));\n        delete priceFeedMap[_priceFeedKey];\n        delete priceFeedDecimalMap[_priceFeedKey];\n\n        uint256 length = priceFeedKeys.length;\n        for (uint256 i; i < length; i++) {\n            if (priceFeedKeys[i] == _priceFeedKey) {\n                // if the removal item is the last one, just `pop`\n                if (i != length - 1) {\n                    priceFeedKeys[i] = priceFeedKeys[length - 1];\n                }\n                priceFeedKeys.pop();\n                break;\n            }\n        }\n    }\n\n    //\n    // VIEW FUNCTIONS\n    //\n\n    function getAggregator(\n        bytes32 _priceFeedKey\n    ) public view returns (AggregatorV3Interface) {\n        return priceFeedMap[_priceFeedKey];\n    }\n\n    //\n    // INTERFACE IMPLEMENTATION\n    //\n\n    function getPrice(\n        bytes32 _priceFeedKey\n    ) external view override returns (uint256) {\n        AggregatorV3Interface aggregator = getAggregator(_priceFeedKey);\n        requireNonEmptyAddress(address(aggregator));\n\n        (, uint256 latestPrice, ) = getLatestRoundData(aggregator);\n        return formatDecimals(latestPrice, priceFeedDecimalMap[_priceFeedKey]);\n    }\n\n    //\n    // INTERNAL VIEW FUNCTIONS\n    //\n\n    function getLatestRoundData(\n        AggregatorV3Interface _aggregator\n    ) internal view returns (uint80, uint256 finalPrice, uint256) {\n        (\n            uint80 round,\n            int256 latestPrice,\n            ,\n            uint256 latestTimestamp,\n\n        ) = _aggregator.latestRoundData();\n        finalPrice = uint256(latestPrice);\n        if (latestPrice < 0) {\n            requireEnoughHistory(round);\n            (round, finalPrice, latestTimestamp) = getRoundData(\n                _aggregator,\n                round - 1\n            );\n        }\n        return (round, finalPrice, latestTimestamp);\n    }\n\n    function getRoundData(\n        AggregatorV3Interface _aggregator,\n        uint80 _round\n    ) internal view returns (uint80, uint256, uint256) {\n        (\n            uint80 round,\n            int256 latestPrice,\n            ,\n            uint256 latestTimestamp,\n\n        ) = _aggregator.getRoundData(_round);\n        while (latestPrice < 0) {\n            requireEnoughHistory(round);\n            round = round - 1;\n            (, latestPrice, , latestTimestamp, ) = _aggregator.getRoundData(\n                round\n            );\n        }\n        return (round, uint256(latestPrice), latestTimestamp);\n    }\n\n    function formatDecimals(\n        uint256 _price,\n        uint8 _decimals\n    ) internal pure returns (uint256) {\n        return _price.mul(TOKEN_DIGIT).div(10 ** uint256(_decimals));\n    }\n\n    //\n    // REQUIRE FUNCTIONS\n    //\n\n    function requireNonEmptyAddress(address _addr) internal pure {\n        require(_addr != address(0), \"empty address\");\n    }\n\n    function requireEnoughHistory(uint80 _round) internal pure {\n        require(_round > 0, \"Not enough history\");\n    }\n\n    function requirePositivePrice(int256 _price) internal pure {\n        // a negative price should be reverted to prevent an extremely large/small premiumFraction\n        require(_price > 0, \"Negative price\");\n    }\n}\n"
    },
    "contracts/ClearingHouse.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"./utils/Decimal.sol\";\nimport {SignedDecimal} from \"./utils/SignedDecimal.sol\";\nimport {MixedDecimal} from \"./utils/MixedDecimal.sol\";\nimport {DecimalERC20} from \"./utils/DecimalERC20.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {OwnerPausableUpgradeable} from \"./OwnerPausable.sol\";\nimport {IAmm} from \"./interfaces/IAmm.sol\";\nimport {IInsuranceFund} from \"./interfaces/IInsuranceFund.sol\";\n\n/**\n                                                                              \n                            ####\n                        @@@@    @@@@                      \n                    /@@@            @@@\\\n                @@@@                    @@@@\n            /@@@                            @@@\\\n        /@@@                                    @@@\\\n    /@@@                                            @@@\\\n ////   ############################################   \\\\\\\\\n  \n                                          \n#############################################################                                                    \n            @@   @@       @@   @@       @@   @@\n            @@   @@       @@   @@       @@   @@       \n            @@   @@       @@   @@       @@   @@       \n            @@   @@       @@   @@       @@   @@       \n            @@   @@       @@   @@       @@   @@       \n            @@   @@       @@   @@       @@   @@       \n            @@   @@       @@   @@       @@   @@       \n            @@   @@       @@   @@       @@   @@       \n        ...........................................                                                    \n    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n...........................................................\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n\n */\n\n/**\n * @title Clearing House\n * @notice\n * - issues and stores positions of traders\n * - settles all collateral between traders\n */\ncontract ClearingHouse is\n    DecimalERC20,\n    OwnerPausableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using Decimal for Decimal.decimal;\n    using SignedDecimal for SignedDecimal.signedDecimal;\n    using MixedDecimal for SignedDecimal.signedDecimal;\n\n    /// @notice BUY = LONG, SELL = SHORT\n    enum Side {\n        BUY,\n        SELL\n    }\n\n    /**\n     * @title Position\n     * @notice This struct records position information\n     * @param size denominated in amm.baseAsset\n     * @param margin isolated margin (collateral amt)\n     * @param openNotional the quoteAsset value of the position. the cost of the position\n     * @param lastUpdatedCumulativePremiumFraction for calculating funding payment, recorded at position update\n     * @param blockNumber recorded at every position update\n     */\n    struct Position {\n        SignedDecimal.signedDecimal size;\n        Decimal.decimal margin;\n        Decimal.decimal openNotional;\n        SignedDecimal.signedDecimal lastUpdatedCumulativePremiumFractionLong;\n        SignedDecimal.signedDecimal lastUpdatedCumulativePremiumFractionShort;\n        uint256 blockNumber;\n    }\n\n    /// @notice records vault position sizes\n    struct TotalPositionSize {\n        SignedDecimal.signedDecimal netPositionSize;\n        Decimal.decimal positionSizeLong;\n        Decimal.decimal positionSizeShort;\n    }\n\n    /// @notice used for avoiding stack too deep error\n    struct PositionResp {\n        Position position;\n        Decimal.decimal exchangedQuoteAssetAmount;\n        Decimal.decimal badDebt;\n        SignedDecimal.signedDecimal exchangedPositionSize;\n        SignedDecimal.signedDecimal fundingPayment;\n        SignedDecimal.signedDecimal realizedPnl;\n        SignedDecimal.signedDecimal marginToVault;\n        SignedDecimal.signedDecimal unrealizedPnlAfter;\n    }\n\n    /// @notice used for avoiding stack too deep error\n    struct CalcRemainMarginReturnParams {\n        SignedDecimal.signedDecimal latestCumulativePremiumFractionLong;\n        SignedDecimal.signedDecimal latestCumulativePremiumFractionShort;\n        SignedDecimal.signedDecimal fundingPayment;\n        Decimal.decimal badDebt;\n        Decimal.decimal remainingMargin;\n    }\n\n    //\n    // STATE VARS\n    //\n\n    IInsuranceFund public insuranceFund;\n    Decimal.decimal public fundingRateDeltaCapRatio;\n\n    // key by amm address\n    mapping(address => mapping(address => Position)) public positionMap;\n    mapping(address => Decimal.decimal) public openInterestNotionalMap;\n    mapping(address => TotalPositionSize) public totalPositionSizeMap;\n    mapping(address => SignedDecimal.signedDecimal[])\n        public cumulativePremiumFractionLong;\n    mapping(address => SignedDecimal.signedDecimal[])\n        public cumulativePremiumFractionShort;\n    mapping(address => address) public repegBots;\n\n    // key by token\n    mapping(address => Decimal.decimal) public tollMap;\n\n    enum PnlCalcOption {\n        SPOT_PRICE,\n        ORACLE\n    }\n\n    //\n    // EVENTS\n    //\n\n    /**\n     * @notice This event is emitted when position is changed\n     * @param trader - trader\n     * @param amm - amm\n     * @param margin - updated margin\n     * @param exchangedPositionNotional - the position notional exchanged in the trade\n     * @param exchangedPositionSize - the position size exchanged in the trade\n     * @param fee - trade fee\n     * @param positionSizeAfter - updated position size\n     * @param realizedPnl - realized pnl on the trade\n     * @param unrealizedPnlAfter - unrealized pnl remaining after the trade\n     * @param badDebt - margin cleared by insurance fund (optimally 0)\n     * @param liquidationPenalty - liquidation fee\n     * @param markPrice - updated mark price\n     * @param fundingPayment - funding payment (+: paid, -: received)\n     */\n    event PositionChanged(\n        address indexed trader,\n        address indexed amm,\n        uint256 margin,\n        uint256 exchangedPositionNotional,\n        int256 exchangedPositionSize,\n        uint256 fee,\n        int256 positionSizeAfter,\n        int256 realizedPnl,\n        int256 unrealizedPnlAfter,\n        uint256 badDebt,\n        uint256 liquidationPenalty,\n        uint256 markPrice,\n        int256 fundingPayment\n    );\n\n    /**\n     * @notice This event is emitted when position is liquidated\n     * @param trader - trader\n     * @param amm - amm\n     * @param liquidator - liquidator\n     * @param liquidatedPositionNotional - liquidated position notional\n     * @param liquidatedPositionSize - liquidated position size\n     * @param liquidationReward - liquidation reward to the liquidator\n     * @param insuranceFundProfit - insurance fund profit on liquidation\n     * @param badDebt - liquidation fee cleared by insurance fund (optimally 0)\n     */\n    event PositionLiquidated(\n        address indexed trader,\n        address indexed amm,\n        address indexed liquidator,\n        uint256 liquidatedPositionNotional,\n        uint256 liquidatedPositionSize,\n        uint256 liquidationReward,\n        uint256 insuranceFundProfit,\n        uint256 badDebt\n    );\n\n    /**\n     * @notice emitted on funding payments\n     * @param amm - amm\n     * @param markPrice - mark price on funding\n     * @param indexPrice - index price on funding\n     * @param premiumFractionLong - total premium longs pay (when +ve), receive (when -ve)\n     * @param premiumFractionShort - total premium shorts receive (when +ve), pay (when -ve)\n     * @param insuranceFundPnl - insurance fund pnl from funding\n     */\n    event FundingPayment(\n        address indexed amm,\n        uint256 markPrice,\n        uint256 indexPrice,\n        int256 premiumFractionLong,\n        int256 premiumFractionShort,\n        int256 insuranceFundPnl\n    );\n\n    /**\n     * @notice emitted on adding or removing margin\n     * @param trader - trader address\n     * @param amm - amm address\n     * @param amount - amount changed\n     * @param fundingPayment - funding payment\n     */\n    event MarginChanged(\n        address indexed trader,\n        address indexed amm,\n        int256 amount,\n        int256 fundingPayment\n    );\n\n    /**\n     * @notice emitted on repeg (convergence event)\n     * @param amm - amm address\n     * @param quoteAssetReserveBefore - quote reserve before repeg\n     * @param baseAssetReserveBefore - base reserve before repeg\n     * @param quoteAssetReserveAfter - quote reserve after repeg\n     * @param baseAssetReserveAfter - base reserve after repeg\n     * @param repegPnl - effective pnl incurred on vault positions after repeg\n     * @param repegDebt - amount borrowed from insurance fund\n     */\n    event Repeg(\n        address indexed amm,\n        uint256 quoteAssetReserveBefore,\n        uint256 baseAssetReserveBefore,\n        uint256 quoteAssetReserveAfter,\n        uint256 baseAssetReserveAfter,\n        int256 repegPnl,\n        uint256 repegDebt\n    );\n\n    /// @notice emitted on setting repeg bots\n    event RepegBotSet(address indexed amm, address indexed bot);\n\n    modifier onlyRepegBot(IAmm _amm) {\n        address sender = _msgSender();\n        require(\n            sender == repegBots[address(_amm)] || sender == owner(),\n            \"not allowed\"\n        );\n        _;\n    }\n\n    //\n    // EXTERNAL\n    //\n\n    function initialize(\n        IInsuranceFund _insuranceFund,\n        uint256 _fundingRateDeltaCapRatio\n    ) external initializer {\n        require(address(_insuranceFund) != address(0), \"addr(0)\");\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n\n        insuranceFund = _insuranceFund;\n        fundingRateDeltaCapRatio = Decimal.decimal(_fundingRateDeltaCapRatio);\n    }\n\n    /**\n     * @notice open a position\n     * @param _amm amm address\n     * @param _side enum Side; BUY for long and SELL for short\n     * @param _quoteAssetAmount quote asset amount in 18 digits. Can Not be 0\n     * @param _leverage leverage in 18 digits. Can Not be 0\n     * @param _baseAssetAmountLimit base asset amount limit in 18 digits (slippage). 0 for any slippage\n     */\n    function openPosition(\n        IAmm _amm,\n        Side _side,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _leverage,\n        Decimal.decimal memory _baseAssetAmountLimit\n    ) external whenNotPaused nonReentrant {\n        _requireAmm(_amm);\n        _requireNonZeroInput(_quoteAssetAmount);\n        _requireNonZeroInput(_leverage);\n        _requireMoreMarginRatio(\n            MixedDecimal.fromDecimal(Decimal.one()).divD(_leverage),\n            _amm.getRatios().initMarginRatio,\n            true\n        );\n        _requireNonSandwich(_amm);\n\n        address trader = _msgSender();\n        PositionResp memory positionResp;\n        // add scope for stack too deep error\n        {\n            int256 oldPositionSize = getPosition(_amm, trader).size.toInt();\n            bool isNewPosition = oldPositionSize == 0 ? true : false;\n\n            // increase or decrease position depends on old position's side and size\n            if (\n                isNewPosition ||\n                (oldPositionSize > 0 ? Side.BUY : Side.SELL) == _side\n            ) {\n                positionResp = _internalIncreasePosition(\n                    _amm,\n                    _side,\n                    _quoteAssetAmount.mulD(_leverage),\n                    _baseAssetAmountLimit,\n                    _leverage\n                );\n            } else {\n                positionResp = _openReversePosition(\n                    _amm,\n                    _side,\n                    trader,\n                    _quoteAssetAmount,\n                    _leverage,\n                    _baseAssetAmountLimit,\n                    false\n                );\n            }\n\n            // update position\n            setPosition(_amm, trader, positionResp.position);\n            // opening opposite exact position size as the existing one == closePosition, can skip the margin ratio check\n            if (!isNewPosition && positionResp.position.size.toInt() != 0) {\n                _requireMoreMarginRatio(\n                    getMarginRatio(_amm, trader),\n                    _amm.getRatios().maintenanceMarginRatio,\n                    true\n                );\n            }\n\n            require(positionResp.badDebt.toUint() == 0, \"bad debt\");\n\n            // transfer the token between trader and vault\n            IERC20 quoteToken = _amm.quoteAsset();\n            if (positionResp.marginToVault.toInt() > 0) {\n                _transferFrom(\n                    quoteToken,\n                    trader,\n                    address(this),\n                    positionResp.marginToVault.abs()\n                );\n            } else if (positionResp.marginToVault.toInt() < 0) {\n                _withdraw(quoteToken, trader, positionResp.marginToVault.abs());\n            }\n        }\n\n        // fees\n        Decimal.decimal memory fees = _transferFees(\n            trader,\n            _amm,\n            positionResp.exchangedQuoteAssetAmount,\n            _side,\n            true\n        );\n\n        // emit event\n        uint256 markPrice = _amm.getMarkPrice().toUint();\n        int256 fundingPayment = positionResp.fundingPayment.toInt(); // pre-fetch for stack too deep error\n        emit PositionChanged(\n            trader,\n            address(_amm),\n            positionResp.position.margin.toUint(),\n            positionResp.exchangedQuoteAssetAmount.toUint(),\n            positionResp.exchangedPositionSize.toInt(),\n            fees.toUint(),\n            positionResp.position.size.toInt(),\n            positionResp.realizedPnl.toInt(),\n            positionResp.unrealizedPnlAfter.toInt(),\n            positionResp.badDebt.toUint(),\n            0,\n            markPrice,\n            fundingPayment\n        );\n    }\n\n    /**\n     * @notice close position\n     * @param _amm amm address\n     * @param _quoteAssetAmountLimit quote asset amount limit in 18 digits (slippage). 0 for any slippage\n     */\n    function closePosition(\n        IAmm _amm,\n        Decimal.decimal memory _quoteAssetAmountLimit\n    ) external whenNotPaused nonReentrant {\n        _requireAmm(_amm);\n        _requireNonSandwich(_amm);\n\n        address trader = _msgSender();\n        PositionResp memory positionResp;\n        Position memory position = getPosition(_amm, trader);\n\n        // add scope for stack too deep error\n        {\n            // closing a long means taking a short\n            IAmm.Dir dirOfBase = position.size.toInt() > 0\n                ? IAmm.Dir.ADD_TO_AMM\n                : IAmm.Dir.REMOVE_FROM_AMM;\n\n            IAmm.Ratios memory ratios = _amm.getRatios();\n\n            // if trade goes over fluctuation limit, then partial close, else full close\n            if (\n                _amm.isOverFluctuationLimit(dirOfBase, position.size.abs()) &&\n                ratios.partialLiquidationRatio.toUint() != 0\n            ) {\n                positionResp = _internalPartialClose(\n                    _amm,\n                    trader,\n                    ratios.partialLiquidationRatio,\n                    Decimal.zero()\n                );\n            } else {\n                positionResp = _internalClosePosition(\n                    _amm,\n                    trader,\n                    _quoteAssetAmountLimit\n                );\n            }\n\n            require(positionResp.badDebt.toUint() == 0, \"bad debt\");\n\n            // transfer the token from trader and vault\n            IERC20 quoteToken = _amm.quoteAsset();\n            _withdraw(quoteToken, trader, positionResp.marginToVault.abs());\n        }\n\n        // fees\n        Decimal.decimal memory fees = _transferFees(\n            trader,\n            _amm,\n            positionResp.exchangedQuoteAssetAmount,\n            position.size.toInt() > 0 ? Side.SELL : Side.BUY,\n            false\n        );\n\n        // emit event\n        uint256 markPrice = _amm.getMarkPrice().toUint();\n        int256 fundingPayment = positionResp.fundingPayment.toInt();\n        emit PositionChanged(\n            trader,\n            address(_amm),\n            positionResp.position.margin.toUint(),\n            positionResp.exchangedQuoteAssetAmount.toUint(),\n            positionResp.exchangedPositionSize.toInt(),\n            fees.toUint(),\n            positionResp.position.size.toInt(),\n            positionResp.realizedPnl.toInt(),\n            positionResp.unrealizedPnlAfter.toInt(),\n            positionResp.badDebt.toUint(),\n            0,\n            markPrice,\n            fundingPayment\n        );\n    }\n\n    /**\n     * @notice partially close position\n     * @param _amm amm address\n     * @param _partialCloseRatio % to close\n     * @param _quoteAssetAmountLimit quote asset amount limit in 18 digits (slippage). 0 for any slippage\n     */\n    function partialClose(\n        IAmm _amm,\n        Decimal.decimal memory _partialCloseRatio,\n        Decimal.decimal memory _quoteAssetAmountLimit\n    ) external whenNotPaused nonReentrant {\n        _requireAmm(_amm);\n        _requireNonZeroInput(_partialCloseRatio);\n        require(_partialCloseRatio.cmp(Decimal.one()) < 0, \"not partial close\");\n        _requireNonSandwich(_amm);\n\n        address trader = _msgSender();\n        Position memory position = getPosition(_amm, trader);\n        SignedDecimal.signedDecimal memory sizeToClose = position.size.mulD(\n            _partialCloseRatio\n        );\n\n        // if partial close causes price to go over fluctuation limit, trim down to partial liq ratio\n        Decimal.decimal memory partialLiquidationRatio = _amm\n            .getRatios()\n            .partialLiquidationRatio;\n        if (\n            _amm.isOverFluctuationLimit(\n                position.size.toInt() > 0\n                    ? IAmm.Dir.ADD_TO_AMM\n                    : IAmm.Dir.REMOVE_FROM_AMM,\n                sizeToClose.abs()\n            ) &&\n            partialLiquidationRatio.toUint() != 0 &&\n            _partialCloseRatio.cmp(partialLiquidationRatio) > 0\n        ) {\n            _partialCloseRatio = partialLiquidationRatio;\n        }\n\n        PositionResp memory positionResp = _internalPartialClose(\n            _amm,\n            trader,\n            _partialCloseRatio,\n            _quoteAssetAmountLimit\n        );\n\n        require(positionResp.badDebt.toUint() == 0, \"bad debt\");\n\n        // transfer the token from trader and vault\n        IERC20 quoteToken = _amm.quoteAsset();\n        _withdraw(quoteToken, trader, positionResp.marginToVault.abs());\n\n        // fees\n        Decimal.decimal memory fees = _transferFees(\n            trader,\n            _amm,\n            positionResp.exchangedQuoteAssetAmount,\n            position.size.toInt() > 0 ? Side.SELL : Side.BUY,\n            false\n        );\n\n        // emit event\n        uint256 markPrice = _amm.getMarkPrice().toUint();\n        int256 fundingPayment = positionResp.fundingPayment.toInt();\n\n        emit PositionChanged(\n            trader,\n            address(_amm),\n            positionResp.position.margin.toUint(),\n            positionResp.exchangedQuoteAssetAmount.toUint(),\n            positionResp.exchangedPositionSize.toInt(),\n            fees.toUint(),\n            positionResp.position.size.toInt(),\n            positionResp.realizedPnl.toInt(),\n            positionResp.unrealizedPnlAfter.toInt(),\n            positionResp.badDebt.toUint(),\n            0,\n            markPrice,\n            fundingPayment\n        );\n    }\n\n    /**\n     * @notice add margin to increase margin ratio\n     * @param _amm amm address\n     * @param _addedMargin added margin in 18 digits\n     */\n    function addMargin(\n        IAmm _amm,\n        Decimal.decimal calldata _addedMargin\n    ) external whenNotPaused nonReentrant {\n        _requireAmm(_amm);\n        _requireNonZeroInput(_addedMargin);\n\n        address trader = _msgSender();\n        Position memory position = getPosition(_amm, trader);\n        // update margin\n        position.margin = position.margin.addD(_addedMargin);\n\n        setPosition(_amm, trader, position);\n        // transfer token from trader\n        IERC20 quoteToken = _amm.quoteAsset();\n        _transferFrom(quoteToken, trader, address(this), _addedMargin);\n        emit MarginChanged(\n            trader,\n            address(_amm),\n            int256(_addedMargin.toUint()),\n            0\n        );\n    }\n\n    /**\n     * @notice remove margin to decrease margin ratio\n     * @param _amm amm address\n     * @param _removedMargin removed margin in 18 digits\n     */\n    function removeMargin(\n        IAmm _amm,\n        Decimal.decimal calldata _removedMargin\n    ) external whenNotPaused nonReentrant {\n        _requireAmm(_amm);\n        _requireNonZeroInput(_removedMargin);\n\n        address trader = _msgSender();\n        // realize funding payment if there's no bad debt\n        Position memory position = getPosition(_amm, trader);\n\n        // update margin and cumulativePremiumFraction\n        SignedDecimal.signedDecimal memory marginDelta = MixedDecimal\n            .fromDecimal(_removedMargin)\n            .mulScalar(-1);\n        CalcRemainMarginReturnParams\n            memory calcRemainMarginReturnParams = _calcRemainMarginWithFundingPayment(\n                _amm,\n                position,\n                marginDelta\n            );\n        require(calcRemainMarginReturnParams.badDebt.toUint() == 0, \"bad debt\");\n\n        position.margin = calcRemainMarginReturnParams.remainingMargin;\n        position\n            .lastUpdatedCumulativePremiumFractionLong = calcRemainMarginReturnParams\n            .latestCumulativePremiumFractionLong;\n        position\n            .lastUpdatedCumulativePremiumFractionShort = calcRemainMarginReturnParams\n            .latestCumulativePremiumFractionShort;\n\n        // check enough margin\n        // Use a more conservative way to restrict traders to remove their margin\n        // We don't allow unrealized PnL to support their margin removal\n        require(\n            _calcFreeCollateral(\n                _amm,\n                trader,\n                calcRemainMarginReturnParams.remainingMargin\n            ).toInt() >= 0,\n            \"free collateral is not enough\"\n        );\n\n        // update position\n        setPosition(_amm, trader, position);\n\n        // transfer token back to trader\n        IERC20 quoteToken = _amm.quoteAsset();\n        _withdraw(quoteToken, trader, _removedMargin);\n        emit MarginChanged(\n            trader,\n            address(_amm),\n            marginDelta.toInt(),\n            calcRemainMarginReturnParams.fundingPayment.toInt()\n        );\n    }\n\n    /**\n     * @notice liquidate trader's underwater position. Require trader's margin ratio less than maintenance margin ratio\n     * @param _amm amm address\n     * @param _trader trader address\n     */\n    function liquidate(IAmm _amm, address _trader) external nonReentrant {\n        _internalLiquidate(_amm, _trader);\n    }\n\n    /**\n     * @notice settle funding payment\n     * @dev dynamic funding mechanism refer (https://nftperp.notion.site/Technical-Stuff-8e4cb30f08b94aa2a576097a5008df24)\n     * @param _amm amm address\n     */\n    function settleFunding(IAmm _amm) external whenNotPaused {\n        _requireAmm(_amm);\n\n        (\n            SignedDecimal.signedDecimal memory premiumFraction,\n            Decimal.decimal memory markPrice,\n            Decimal.decimal memory indexPrice\n        ) = _amm.settleFunding();\n\n        /**\n         * implement dynamic funding\n         * premium fraction long = premium fraction * ((PSL * PSS) / PSL)\n         * premium fraction short = premium fraction * ((PSL * PSS) / PSS)\n         * funding rate longs = long premium / index\n         * funding rate shorts = short premium / index\n         */\n\n        TotalPositionSize memory tps = totalPositionSizeMap[address(_amm)];\n        Decimal.decimal memory squaredPositionSizeProduct = tps\n            .positionSizeLong\n            .mulD(tps.positionSizeShort)\n            .sqrt();\n\n        SignedDecimal.signedDecimal memory premiumFractionLong;\n        SignedDecimal.signedDecimal memory premiumFractionShort;\n        SignedDecimal.signedDecimal memory insuranceFundPnl;\n\n        // if PSL or PSL is zero, use regular funding\n        if (squaredPositionSizeProduct.toUint() == 0) {\n            premiumFractionLong = premiumFraction;\n            premiumFractionShort = premiumFraction;\n            insuranceFundPnl = tps.netPositionSize.mulD(premiumFraction);\n        } else {\n            premiumFractionLong = premiumFraction.mulD(\n                squaredPositionSizeProduct.divD(tps.positionSizeLong)\n            );\n            premiumFractionShort = premiumFraction.mulD(\n                squaredPositionSizeProduct.divD(tps.positionSizeShort)\n            );\n        }\n\n        SignedDecimal.signedDecimal memory fundingRateLong = premiumFractionLong\n            .divD(indexPrice);\n        SignedDecimal.signedDecimal\n            memory fundingRateShort = premiumFractionShort.divD(indexPrice);\n        Decimal.decimal memory fundingRateDeltaAbs = fundingRateLong\n            .subD(fundingRateShort)\n            .abs();\n\n        // capped dynamic funding, funding rate of a side is capped if it is more than fundingRateDeltaCapRatio\n        if (fundingRateDeltaAbs.cmp(fundingRateDeltaCapRatio) <= 0) {\n            // no capping\n            _amm.updateFundingRate(\n                premiumFractionLong,\n                premiumFractionShort,\n                indexPrice\n            );\n        } else {\n            // capping\n            Decimal.decimal memory x = fundingRateDeltaCapRatio.mulD(\n                indexPrice\n            ); /** @aster2709: not sure what to call this :p  */\n\n            if (premiumFraction.toInt() > 0) {\n                // longs pay shorts\n                if (\n                    premiumFractionLong.toInt() > premiumFractionShort.toInt()\n                ) {\n                    // cap long losses, insurnace fund covers beyond cap\n                    SignedDecimal.signedDecimal\n                        memory newPremiumFractionLong = premiumFractionShort\n                            .addD(x);\n                    SignedDecimal.signedDecimal\n                        memory coveredPremium = premiumFractionLong.subD(\n                            newPremiumFractionLong\n                        );\n                    insuranceFundPnl = coveredPremium\n                        .mulD(tps.positionSizeLong)\n                        .mulScalar(-1);\n                    premiumFractionLong = newPremiumFractionLong;\n                } else {\n                    // cap short profits, insurance fund benefits beyond cap\n                    SignedDecimal.signedDecimal\n                        memory newPremiumFractionShort = premiumFractionLong\n                            .addD(x);\n                    SignedDecimal.signedDecimal\n                        memory coveredPremium = premiumFractionShort.subD(\n                            newPremiumFractionShort\n                        );\n                    insuranceFundPnl = coveredPremium.mulD(\n                        tps.positionSizeShort\n                    );\n                    premiumFractionShort = newPremiumFractionShort;\n                }\n            } else {\n                // shorts pay longs\n                if (\n                    premiumFractionLong.toInt() < premiumFractionShort.toInt()\n                ) {\n                    // cap long profits, insurnace fund benefits beyond cap\n                    SignedDecimal.signedDecimal\n                        memory newPremiumFractionLong = premiumFractionShort\n                            .subD(x);\n                    SignedDecimal.signedDecimal\n                        memory coveredPremium = premiumFractionLong.subD(\n                            newPremiumFractionLong\n                        );\n                    insuranceFundPnl = coveredPremium\n                        .mulD(tps.positionSizeLong)\n                        .mulScalar(-1);\n                } else {\n                    // cap short losses, insurnace fund covers beyond cap\n                    SignedDecimal.signedDecimal\n                        memory newPremiumFractionShort = premiumFractionLong\n                            .subD(x);\n                    SignedDecimal.signedDecimal\n                        memory coveredPremium = premiumFractionShort.subD(\n                            newPremiumFractionShort\n                        );\n                    insuranceFundPnl = coveredPremium.mulD(\n                        tps.positionSizeShort\n                    );\n                    premiumFractionShort = newPremiumFractionShort;\n                }\n            }\n            _amm.updateFundingRate(\n                premiumFractionLong,\n                premiumFractionShort,\n                indexPrice\n            );\n        }\n\n        // update cumulative premium fractions\n        (\n            SignedDecimal.signedDecimal\n                memory latestCumulativePremiumFractionLong,\n            SignedDecimal.signedDecimal\n                memory latestCumulativePremiumFractionShort\n        ) = getLatestCumulativePremiumFraction(_amm);\n        cumulativePremiumFractionLong[address(_amm)].push(\n            premiumFractionLong.addD(latestCumulativePremiumFractionLong)\n        );\n        cumulativePremiumFractionShort[address(_amm)].push(\n            premiumFractionShort.addD(latestCumulativePremiumFractionShort)\n        );\n\n        // settle insurance fund pnl\n        IERC20 quoteToken = _amm.quoteAsset();\n        if (insuranceFundPnl.toInt() > 0) {\n            _transferToInsuranceFund(quoteToken, insuranceFundPnl.abs());\n        } else if (insuranceFundPnl.toInt() < 0) {\n            insuranceFund.withdraw(quoteToken, insuranceFundPnl.abs());\n        }\n        emit FundingPayment(\n            address(_amm),\n            markPrice.toUint(),\n            indexPrice.toUint(),\n            premiumFractionLong.toInt(),\n            premiumFractionShort.toInt(),\n            insuranceFundPnl.toInt()\n        );\n    }\n\n    /**\n     * @notice repeg mark price to index price\n     * @dev only repeg bot can call\n     * @param _amm amm address\n     */\n    function repegPrice(IAmm _amm) external onlyRepegBot(_amm) {\n        (\n            Decimal.decimal memory quoteAssetBefore,\n            Decimal.decimal memory baseAssetBefore,\n            Decimal.decimal memory quoteAssetAfter,\n            Decimal.decimal memory baseAssetAfter,\n            SignedDecimal.signedDecimal memory repegPnl\n        ) = _amm.repegPrice();\n        Decimal.decimal memory repegDebt = _settleRepegPnl(_amm, repegPnl);\n\n        emit Repeg(\n            address(_amm),\n            quoteAssetBefore.toUint(),\n            baseAssetBefore.toUint(),\n            quoteAssetAfter.toUint(),\n            baseAssetAfter.toUint(),\n            repegPnl.toInt(),\n            repegDebt.toUint()\n        );\n    }\n\n    function repegLiquidityDepth(\n        IAmm _amm,\n        Decimal.decimal memory _multiplier\n    ) external onlyRepegBot(_amm) {\n        (\n            Decimal.decimal memory quoteAssetBefore,\n            Decimal.decimal memory baseAssetBefore,\n            Decimal.decimal memory quoteAssetAfter,\n            Decimal.decimal memory baseAssetAfter,\n            SignedDecimal.signedDecimal memory repegPnl\n        ) = _amm.repegK(_multiplier);\n        Decimal.decimal memory repegDebt = _settleRepegPnl(_amm, repegPnl);\n\n        emit Repeg(\n            address(_amm),\n            quoteAssetBefore.toUint(),\n            baseAssetBefore.toUint(),\n            quoteAssetAfter.toUint(),\n            baseAssetAfter.toUint(),\n            repegPnl.toInt(),\n            repegDebt.toUint()\n        );\n    }\n\n    /**\n     * @notice set repeg bot\n     * @dev only owner\n     * @param _amm amm address\n     * @param _repegBot bot address to be set\n     */\n    function setRepegBot(address _amm, address _repegBot) external onlyOwner {\n        repegBots[_amm] = _repegBot;\n        emit RepegBotSet(_amm, _repegBot);\n    }\n\n    //\n    // PUBLIC\n    //\n\n    /**\n     * @notice get personal position information\n     * @param _amm IAmm address\n     * @param _trader trader address\n     * @return struct Position\n     */\n    function getPosition(\n        IAmm _amm,\n        address _trader\n    ) public view returns (Position memory) {\n        return positionMap[address(_amm)][_trader];\n    }\n\n    /**\n     * @notice get margin ratio, marginRatio = (margin + funding payment + unrealized Pnl) / positionNotional\n     * @param _amm amm address\n     * @param _trader trader address\n     * @return margin ratio in 18 digits\n     */\n    function getMarginRatio(\n        IAmm _amm,\n        address _trader\n    ) public view returns (SignedDecimal.signedDecimal memory) {\n        return\n            _getMarginRatioByCalcOption(\n                _amm,\n                _trader,\n                PnlCalcOption.SPOT_PRICE\n            );\n    }\n\n    /**\n     * @notice get position notional and unrealized Pnl without fee expense and funding payment\n     * @param _amm amm address\n     * @param _trader trader address\n     * @param _pnlCalcOption enum PnlCalcOption, SPOT_PRICE for spot price and ORACLE for oracle price\n     * @return positionNotional position notional\n     * @return unrealizedPnl unrealized Pnl\n     */\n    function getPositionNotionalAndUnrealizedPnl(\n        IAmm _amm,\n        address _trader,\n        PnlCalcOption _pnlCalcOption\n    )\n        public\n        view\n        returns (\n            Decimal.decimal memory positionNotional,\n            SignedDecimal.signedDecimal memory unrealizedPnl\n        )\n    {\n        Position memory position = getPosition(_amm, _trader);\n        Decimal.decimal memory positionSizeAbs = position.size.abs();\n        if (positionSizeAbs.toUint() != 0) {\n            bool isShortPosition = position.size.toInt() < 0;\n            IAmm.Dir dir = isShortPosition\n                ? IAmm.Dir.REMOVE_FROM_AMM\n                : IAmm.Dir.ADD_TO_AMM;\n            if (_pnlCalcOption == PnlCalcOption.SPOT_PRICE) {\n                positionNotional = _amm.getOutputPrice(dir, positionSizeAbs);\n            } else {\n                Decimal.decimal memory oraclePrice = _amm.getIndexPrice();\n                positionNotional = positionSizeAbs.mulD(oraclePrice);\n            }\n            // unrealizedPnlForLongPosition = positionNotional - openNotional\n            // unrealizedPnlForShortPosition = positionNotionalWhenBorrowed - positionNotionalWhenReturned =\n            // openNotional - positionNotional = unrealizedPnlForLongPosition * -1\n            unrealizedPnl = isShortPosition\n                ? MixedDecimal.fromDecimal(position.openNotional).subD(\n                    positionNotional\n                )\n                : MixedDecimal.fromDecimal(positionNotional).subD(\n                    position.openNotional\n                );\n        }\n    }\n\n    /**\n     * @notice get latest cumulative premium fraction.\n     * @param _amm IAmm address\n     * @return latestCumulativePremiumFractionLong cumulative premium fraction long\n     * @return latestCumulativePremiumFractionShort cumulative premium fraction short\n     */\n    function getLatestCumulativePremiumFraction(\n        IAmm _amm\n    )\n        public\n        view\n        returns (\n            SignedDecimal.signedDecimal\n                memory latestCumulativePremiumFractionLong,\n            SignedDecimal.signedDecimal\n                memory latestCumulativePremiumFractionShort\n        )\n    {\n        address amm = address(_amm);\n        uint256 lenLong = cumulativePremiumFractionLong[amm].length;\n        uint256 lenShort = cumulativePremiumFractionShort[amm].length;\n        if (lenLong > 0) {\n            latestCumulativePremiumFractionLong = cumulativePremiumFractionLong[\n                amm\n            ][lenLong - 1];\n        }\n        if (lenShort > 0) {\n            latestCumulativePremiumFractionShort = cumulativePremiumFractionShort[\n                amm\n            ][lenShort - 1];\n        }\n    }\n\n    //\n    // INTERNAL\n    //\n\n    function _getMarginRatio(\n        IAmm _amm,\n        Position memory _position,\n        SignedDecimal.signedDecimal memory _unrealizedPnl,\n        Decimal.decimal memory _positionNotional\n    ) internal view returns (SignedDecimal.signedDecimal memory) {\n        CalcRemainMarginReturnParams\n            memory calcRemainMarginReturnParams = _calcRemainMarginWithFundingPayment(\n                _amm,\n                _position,\n                _unrealizedPnl\n            );\n        return\n            MixedDecimal\n                .fromDecimal(calcRemainMarginReturnParams.remainingMargin)\n                .subD(calcRemainMarginReturnParams.badDebt)\n                .divD(_positionNotional);\n    }\n\n    // only called from openPosition and _closeAndOpenReversePosition. calling fn needs to ensure there's enough marginRatio\n    function _internalIncreasePosition(\n        IAmm _amm,\n        Side _side,\n        Decimal.decimal memory _openNotional,\n        Decimal.decimal memory _minPositionSize,\n        Decimal.decimal memory _leverage\n    ) internal returns (PositionResp memory positionResp) {\n        address trader = _msgSender();\n        Position memory oldPosition = getPosition(_amm, trader);\n        positionResp.exchangedPositionSize = _swapInput(\n            _amm,\n            _side,\n            _openNotional,\n            _minPositionSize,\n            false\n        );\n        SignedDecimal.signedDecimal memory newSize = oldPosition.size.addD(\n            positionResp.exchangedPositionSize\n        );\n\n        _updateOpenInterestNotional(\n            _amm,\n            MixedDecimal.fromDecimal(_openNotional)\n        );\n        _updateTotalPositionSize(\n            _amm,\n            positionResp.exchangedPositionSize,\n            _side\n        );\n\n        Decimal.decimal memory maxHoldingBaseAsset = _amm\n            .getMaxHoldingBaseAsset();\n        if (maxHoldingBaseAsset.toUint() != 0) {\n            // total position size should be less than `positionUpperBound`\n            require(\n                newSize.abs().cmp(maxHoldingBaseAsset) <= 0,\n                \"positionSize cap\"\n            );\n        }\n\n        SignedDecimal.signedDecimal memory marginToAdd = MixedDecimal\n            .fromDecimal(_openNotional.divD(_leverage));\n        CalcRemainMarginReturnParams\n            memory calcRemainMarginReturnParams = _calcRemainMarginWithFundingPayment(\n                _amm,\n                oldPosition,\n                marginToAdd\n            );\n\n        (\n            ,\n            SignedDecimal.signedDecimal memory unrealizedPnl\n        ) = getPositionNotionalAndUnrealizedPnl(\n                _amm,\n                trader,\n                PnlCalcOption.SPOT_PRICE\n            );\n\n        // update positionResp\n        positionResp.exchangedQuoteAssetAmount = _openNotional;\n        positionResp.unrealizedPnlAfter = unrealizedPnl;\n        positionResp.marginToVault = marginToAdd;\n        positionResp.fundingPayment = calcRemainMarginReturnParams\n            .fundingPayment;\n        positionResp.position = Position(\n            newSize,\n            calcRemainMarginReturnParams.remainingMargin,\n            oldPosition.openNotional.addD(\n                positionResp.exchangedQuoteAssetAmount\n            ),\n            calcRemainMarginReturnParams.latestCumulativePremiumFractionLong,\n            calcRemainMarginReturnParams.latestCumulativePremiumFractionShort,\n            block.number\n        );\n    }\n\n    function _openReversePosition(\n        IAmm _amm,\n        Side _side,\n        address _trader,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _leverage,\n        Decimal.decimal memory _baseAssetAmountLimit,\n        bool _canOverFluctuationLimit\n    ) internal returns (PositionResp memory) {\n        Decimal.decimal memory openNotional = _quoteAssetAmount.mulD(_leverage);\n        (\n            Decimal.decimal memory oldPositionNotional,\n            SignedDecimal.signedDecimal memory unrealizedPnl\n        ) = getPositionNotionalAndUnrealizedPnl(\n                _amm,\n                _trader,\n                PnlCalcOption.SPOT_PRICE\n            );\n        PositionResp memory positionResp;\n\n        // reduce position if old position is larger\n        if (oldPositionNotional.toUint() > openNotional.toUint()) {\n            // for reducing oi and tps from respective side\n\n            Position memory oldPosition = getPosition(_amm, _trader);\n            {\n                positionResp.exchangedPositionSize = _swapInput(\n                    _amm,\n                    _side,\n                    openNotional,\n                    _baseAssetAmountLimit,\n                    _canOverFluctuationLimit\n                );\n\n                // realizedPnl = unrealizedPnl * closedRatio\n                // closedRatio = positionResp.exchangedPositionSize / oldPosition.size\n                if (oldPosition.size.toInt() != 0) {\n                    positionResp.realizedPnl = unrealizedPnl\n                        .mulD(positionResp.exchangedPositionSize.abs())\n                        .divD(oldPosition.size.abs());\n                }\n\n                CalcRemainMarginReturnParams\n                    memory calcRemainMarginReturnParams = _calcRemainMarginWithFundingPayment(\n                        _amm,\n                        oldPosition,\n                        positionResp.realizedPnl\n                    );\n\n                // positionResp.unrealizedPnlAfter = unrealizedPnl - realizedPnl\n                positionResp.unrealizedPnlAfter = unrealizedPnl.subD(\n                    positionResp.realizedPnl\n                );\n                positionResp.exchangedQuoteAssetAmount = openNotional;\n\n                // calculate openNotional (it's different depends on long or short side)\n                // long: unrealizedPnl = positionNotional - openNotional => openNotional = positionNotional - unrealizedPnl\n                // short: unrealizedPnl = openNotional - positionNotional => openNotional = positionNotional + unrealizedPnl\n                // positionNotional = oldPositionNotional - exchangedQuoteAssetAmount\n                SignedDecimal.signedDecimal\n                    memory remainOpenNotional = oldPosition.size.toInt() > 0\n                        ? MixedDecimal\n                            .fromDecimal(oldPositionNotional)\n                            .subD(positionResp.exchangedQuoteAssetAmount)\n                            .subD(positionResp.unrealizedPnlAfter)\n                        : positionResp\n                            .unrealizedPnlAfter\n                            .addD(oldPositionNotional)\n                            .subD(positionResp.exchangedQuoteAssetAmount);\n                require(remainOpenNotional.toInt() > 0, \"remainNotional <= 0\");\n\n                positionResp.position = Position(\n                    oldPosition.size.addD(positionResp.exchangedPositionSize),\n                    calcRemainMarginReturnParams.remainingMargin,\n                    remainOpenNotional.abs(),\n                    calcRemainMarginReturnParams\n                        .latestCumulativePremiumFractionLong,\n                    calcRemainMarginReturnParams\n                        .latestCumulativePremiumFractionShort,\n                    block.number\n                );\n            }\n\n            // update open interest and total position sizes\n            Side side = _side == Side.BUY ? Side.BUY : Side.SELL; // reduce\n            _updateTotalPositionSize(\n                _amm,\n                positionResp.exchangedPositionSize,\n                side\n            );\n            _updateOpenInterestNotional(\n                _amm,\n                positionResp\n                .realizedPnl\n                .addD(positionResp.badDebt) // bad debt also considers as removed notional\n                    .addD(oldPosition.openNotional)\n                    .subD(positionResp.position.openNotional)\n                    .mulScalar(-1)\n            );\n            return positionResp;\n        }\n        return\n            _closeAndOpenReversePosition(\n                _amm,\n                _side,\n                _trader,\n                _quoteAssetAmount,\n                _leverage,\n                _baseAssetAmountLimit\n            );\n    }\n\n    function _closeAndOpenReversePosition(\n        IAmm _amm,\n        Side _side,\n        address _trader,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _leverage,\n        Decimal.decimal memory _baseAssetAmountLimit\n    ) internal returns (PositionResp memory positionResp) {\n        // new position size is larger than or equal to the old position size\n        // so either close or close then open a larger position\n        PositionResp memory closePositionResp = _internalClosePosition(\n            _amm,\n            _trader,\n            Decimal.zero()\n        );\n\n        // the old position is underwater. trader should close a position first\n        require(closePositionResp.badDebt.toUint() == 0, \"bad debt\");\n\n        // update open notional after closing position\n        Decimal.decimal memory openNotional = _quoteAssetAmount\n            .mulD(_leverage)\n            .subD(closePositionResp.exchangedQuoteAssetAmount);\n\n        // if remain exchangedQuoteAssetAmount is too small (eg. 1wei) then the required margin might be 0\n        // then the clearingHouse will stop opening position\n        if (openNotional.divD(_leverage).toUint() == 0) {\n            positionResp = closePositionResp;\n        } else {\n            Decimal.decimal memory updatedBaseAssetAmountLimit;\n            if (\n                _baseAssetAmountLimit.toUint() >\n                closePositionResp.exchangedPositionSize.toUint()\n            ) {\n                updatedBaseAssetAmountLimit = _baseAssetAmountLimit.subD(\n                    closePositionResp.exchangedPositionSize.abs()\n                );\n            }\n\n            PositionResp\n                memory increasePositionResp = _internalIncreasePosition(\n                    _amm,\n                    _side,\n                    openNotional,\n                    updatedBaseAssetAmountLimit,\n                    _leverage\n                );\n            positionResp = PositionResp({\n                position: increasePositionResp.position,\n                exchangedQuoteAssetAmount: closePositionResp\n                    .exchangedQuoteAssetAmount\n                    .addD(increasePositionResp.exchangedQuoteAssetAmount),\n                badDebt: closePositionResp.badDebt.addD(\n                    increasePositionResp.badDebt\n                ),\n                fundingPayment: closePositionResp.fundingPayment.addD(\n                    increasePositionResp.fundingPayment\n                ),\n                exchangedPositionSize: closePositionResp\n                    .exchangedPositionSize\n                    .addD(increasePositionResp.exchangedPositionSize),\n                realizedPnl: closePositionResp.realizedPnl.addD(\n                    increasePositionResp.realizedPnl\n                ),\n                unrealizedPnlAfter: SignedDecimal.zero(),\n                marginToVault: closePositionResp.marginToVault.addD(\n                    increasePositionResp.marginToVault\n                )\n            });\n        }\n        return positionResp;\n    }\n\n    function _internalClosePosition(\n        IAmm _amm,\n        address _trader,\n        Decimal.decimal memory _quoteAssetAmountLimit\n    ) internal returns (PositionResp memory positionResp) {\n        // check conditions\n        Position memory oldPosition = getPosition(_amm, _trader);\n        _requirePositionSize(oldPosition.size);\n\n        (\n            ,\n            SignedDecimal.signedDecimal memory unrealizedPnl\n        ) = getPositionNotionalAndUnrealizedPnl(\n                _amm,\n                _trader,\n                PnlCalcOption.SPOT_PRICE\n            );\n        CalcRemainMarginReturnParams\n            memory calcRemainMarginReturnParams = _calcRemainMarginWithFundingPayment(\n                _amm,\n                oldPosition,\n                unrealizedPnl\n            );\n\n        positionResp.exchangedPositionSize = oldPosition.size.mulScalar(-1);\n        positionResp.realizedPnl = unrealizedPnl;\n        positionResp.badDebt = calcRemainMarginReturnParams.badDebt;\n        positionResp.fundingPayment = calcRemainMarginReturnParams\n            .fundingPayment;\n        positionResp.marginToVault = MixedDecimal\n            .fromDecimal(calcRemainMarginReturnParams.remainingMargin)\n            .mulScalar(-1);\n\n        // for amm.swapOutput, the direction is in base asset, from the perspective of Amm\n        positionResp.exchangedQuoteAssetAmount = _amm.swapOutput(\n            oldPosition.size.toInt() > 0\n                ? IAmm.Dir.ADD_TO_AMM\n                : IAmm.Dir.REMOVE_FROM_AMM,\n            oldPosition.size.abs(),\n            _quoteAssetAmountLimit\n        );\n\n        Side side = oldPosition.size.toInt() > 0 ? Side.BUY : Side.SELL;\n        // bankrupt position's bad debt will be also consider as a part of the open interest\n        _updateOpenInterestNotional(\n            _amm,\n            unrealizedPnl\n                .addD(calcRemainMarginReturnParams.badDebt)\n                .addD(oldPosition.openNotional)\n                .mulScalar(-1)\n        );\n        _updateTotalPositionSize(\n            _amm,\n            positionResp.exchangedPositionSize,\n            side\n        );\n        _clearPosition(_amm, _trader);\n    }\n\n    function _internalPartialClose(\n        IAmm _amm,\n        address _trader,\n        Decimal.decimal memory _partialCloseRatio,\n        Decimal.decimal memory _quoteAssetAmountLimit\n    ) internal returns (PositionResp memory) {\n        // check conditions\n        Position memory oldPosition = getPosition(_amm, _trader);\n        _requirePositionSize(oldPosition.size);\n\n        (\n            Decimal.decimal memory oldPositionNotional,\n            SignedDecimal.signedDecimal memory unrealizedPnl\n        ) = getPositionNotionalAndUnrealizedPnl(\n                _amm,\n                _trader,\n                PnlCalcOption.SPOT_PRICE\n            );\n\n        SignedDecimal.signedDecimal memory sizeToClose = oldPosition.size.mulD(\n            _partialCloseRatio\n        );\n        SignedDecimal.signedDecimal memory marginToRemove = MixedDecimal\n            .fromDecimal(oldPosition.margin.mulD(_partialCloseRatio));\n\n        PositionResp memory positionResp;\n        CalcRemainMarginReturnParams memory calcRemaingMarginReturnParams;\n        // scope for avoiding stack too deep error\n        {\n            positionResp.exchangedPositionSize = sizeToClose.mulScalar(-1);\n\n            positionResp.realizedPnl = unrealizedPnl.mulD(_partialCloseRatio);\n            positionResp.unrealizedPnlAfter = unrealizedPnl.subD(\n                positionResp.realizedPnl\n            );\n\n            calcRemaingMarginReturnParams = _calcRemainMarginWithFundingPayment(\n                _amm,\n                oldPosition,\n                marginToRemove.mulScalar(-1)\n            );\n            positionResp.badDebt = calcRemaingMarginReturnParams.badDebt;\n            positionResp.fundingPayment = calcRemaingMarginReturnParams\n                .fundingPayment;\n            positionResp.marginToVault = marginToRemove\n                .addD(positionResp.realizedPnl)\n                .mulScalar(-1);\n\n            // for amm.swapOutput, the direction is in base asset, from the perspective of Amm\n            positionResp.exchangedQuoteAssetAmount = _amm.swapOutput(\n                oldPosition.size.toInt() > 0\n                    ? IAmm.Dir.ADD_TO_AMM\n                    : IAmm.Dir.REMOVE_FROM_AMM,\n                sizeToClose.abs(),\n                _quoteAssetAmountLimit\n            );\n        }\n\n        SignedDecimal.signedDecimal memory remainOpenNotional = oldPosition\n            .size\n            .toInt() > 0\n            ? MixedDecimal\n                .fromDecimal(oldPositionNotional)\n                .subD(positionResp.exchangedQuoteAssetAmount)\n                .subD(positionResp.unrealizedPnlAfter)\n            : positionResp.unrealizedPnlAfter.addD(oldPositionNotional).subD(\n                positionResp.exchangedQuoteAssetAmount\n            );\n        require(remainOpenNotional.toInt() > 0, \"value of openNotional <= 0\");\n\n        positionResp.position = Position(\n            oldPosition.size.subD(sizeToClose),\n            calcRemaingMarginReturnParams.remainingMargin,\n            remainOpenNotional.abs(),\n            calcRemaingMarginReturnParams.latestCumulativePremiumFractionLong,\n            calcRemaingMarginReturnParams.latestCumulativePremiumFractionShort,\n            block.number\n        );\n\n        // for reducing oi and tps from respective side\n        Side side = oldPosition.size.toInt() > 0 ? Side.BUY : Side.SELL;\n        _updateOpenInterestNotional(\n            _amm,\n            positionResp\n            .realizedPnl\n            .addD(positionResp.badDebt) // bad debt also considers as removed notional\n                .addD(oldPosition.openNotional)\n                .subD(positionResp.position.openNotional)\n                .mulScalar(-1)\n        );\n        _updateTotalPositionSize(\n            _amm,\n            positionResp.exchangedPositionSize,\n            side\n        );\n\n        // update position\n        setPosition(_amm, _trader, positionResp.position);\n\n        return positionResp;\n    }\n\n    function _internalLiquidate(\n        IAmm _amm,\n        address _trader\n    )\n        internal\n        returns (Decimal.decimal memory quoteAssetAmount, bool isPartialClose)\n    {\n        _requireAmm(_amm);\n\n        SignedDecimal.signedDecimal memory marginRatio = getMarginRatio(\n            _amm,\n            _trader\n        );\n\n        if (_amm.isOverSpreadLimit()) {\n            SignedDecimal.signedDecimal\n                memory marginRatioBasedOnOracle = _getMarginRatioByCalcOption(\n                    _amm,\n                    _trader,\n                    PnlCalcOption.ORACLE\n                );\n            if (marginRatioBasedOnOracle.subD(marginRatio).toInt() > 0) {\n                marginRatio = marginRatioBasedOnOracle;\n            }\n        }\n\n        IAmm.Ratios memory ratios = _amm.getRatios();\n        _requireMoreMarginRatio(\n            marginRatio,\n            ratios.maintenanceMarginRatio,\n            false\n        );\n\n        PositionResp memory positionResp;\n        Decimal.decimal memory liquidationPenalty;\n        {\n            Decimal.decimal memory liquidationBadDebt;\n            Decimal.decimal memory feeToLiquidator;\n            Decimal.decimal memory feeToInsuranceFund;\n            IERC20 quoteAsset = _amm.quoteAsset();\n\n            // partially liquidate if over liquidation fee ratio\n            if (\n                marginRatio.toInt() >\n                int256(ratios.liquidationFeeRatio.toUint()) &&\n                ratios.partialLiquidationRatio.toUint() != 0\n            ) {\n                Position memory position = getPosition(_amm, _trader);\n\n                Decimal.decimal\n                    memory partiallyLiquidatedPositionNotional = _amm\n                        .getOutputPrice(\n                            position.size.toInt() > 0\n                                ? IAmm.Dir.ADD_TO_AMM\n                                : IAmm.Dir.REMOVE_FROM_AMM,\n                            position\n                                .size\n                                .mulD(ratios.partialLiquidationRatio)\n                                .abs()\n                        );\n\n                positionResp = _openReversePosition(\n                    _amm,\n                    position.size.toInt() > 0 ? Side.SELL : Side.BUY,\n                    _trader,\n                    partiallyLiquidatedPositionNotional,\n                    Decimal.one(),\n                    Decimal.zero(),\n                    true\n                );\n\n                // half of the liquidationFee goes to liquidator & another half goes to insurance fund\n                liquidationPenalty = positionResp\n                    .exchangedQuoteAssetAmount\n                    .mulD(ratios.liquidationFeeRatio);\n                feeToLiquidator = liquidationPenalty.divScalar(2);\n                feeToInsuranceFund = liquidationPenalty.subD(feeToLiquidator);\n\n                positionResp.position.margin = positionResp\n                    .position\n                    .margin\n                    .subD(liquidationPenalty);\n\n                // update position\n                setPosition(_amm, _trader, positionResp.position);\n\n                isPartialClose = true;\n            } else {\n                positionResp = _internalClosePosition(\n                    _amm,\n                    _trader,\n                    Decimal.zero()\n                );\n\n                Decimal.decimal memory remainingMargin = positionResp\n                    .marginToVault\n                    .abs();\n\n                feeToLiquidator = positionResp\n                    .exchangedQuoteAssetAmount\n                    .mulD(ratios.liquidationFeeRatio)\n                    .divScalar(2);\n\n                if (feeToLiquidator.toUint() > remainingMargin.toUint()) {\n                    liquidationBadDebt = feeToLiquidator.subD(remainingMargin);\n                } else {\n                    feeToInsuranceFund = remainingMargin.subD(feeToLiquidator);\n                }\n\n                liquidationPenalty = feeToLiquidator.addD(feeToInsuranceFund);\n            }\n\n            if (feeToInsuranceFund.toUint() > 0) {\n                _transferToInsuranceFund(quoteAsset, feeToInsuranceFund);\n            }\n            // reward liquidator\n            _withdraw(quoteAsset, _msgSender(), feeToLiquidator);\n\n            emit PositionLiquidated(\n                _trader,\n                address(_amm),\n                _msgSender(),\n                positionResp.exchangedQuoteAssetAmount.toUint(),\n                positionResp.exchangedPositionSize.toUint(),\n                feeToLiquidator.toUint(),\n                feeToInsuranceFund.toUint(),\n                liquidationBadDebt.toUint()\n            );\n        }\n\n        // emit event\n        uint256 markPrice = _amm.getMarkPrice().toUint();\n        int256 fundingPayment = positionResp.fundingPayment.toInt();\n        emit PositionChanged(\n            _trader,\n            address(_amm),\n            positionResp.position.margin.toUint(),\n            positionResp.exchangedQuoteAssetAmount.toUint(),\n            positionResp.exchangedPositionSize.toInt(),\n            0,\n            positionResp.position.size.toInt(),\n            positionResp.realizedPnl.toInt(),\n            positionResp.unrealizedPnlAfter.toInt(),\n            positionResp.badDebt.toUint(),\n            liquidationPenalty.toUint(),\n            markPrice,\n            fundingPayment\n        );\n\n        return (positionResp.exchangedQuoteAssetAmount, isPartialClose);\n    }\n\n    function _swapInput(\n        IAmm _amm,\n        Side _side,\n        Decimal.decimal memory _inputAmount,\n        Decimal.decimal memory _minOutputAmount,\n        bool _canOverFluctuationLimit\n    ) internal returns (SignedDecimal.signedDecimal memory) {\n        // for amm.swapInput, the direction is in quote asset, from the perspective of Amm\n        IAmm.Dir dir = (_side == Side.BUY)\n            ? IAmm.Dir.ADD_TO_AMM\n            : IAmm.Dir.REMOVE_FROM_AMM;\n        SignedDecimal.signedDecimal memory outputAmount = MixedDecimal\n            .fromDecimal(\n                _amm.swapInput(\n                    dir,\n                    _inputAmount,\n                    _minOutputAmount,\n                    _canOverFluctuationLimit\n                )\n            );\n        if (IAmm.Dir.REMOVE_FROM_AMM == dir) {\n            return outputAmount.mulScalar(-1);\n        }\n        return outputAmount;\n    }\n\n    function _transferFees(\n        address _from,\n        IAmm _amm,\n        Decimal.decimal memory _positionNotional,\n        Side _side,\n        bool _isOpenPos\n    ) internal returns (Decimal.decimal memory fees) {\n        fees = _amm.calcFee(\n            _side == Side.BUY ? IAmm.Dir.ADD_TO_AMM : IAmm.Dir.REMOVE_FROM_AMM,\n            _positionNotional,\n            _isOpenPos\n        );\n\n        if (fees.toUint() > 0) {\n            IERC20 quoteToken = _amm.quoteAsset();\n            /**\n             * toll fees - fees towards clearing house\n             * spread fees - fees towards insurance fund\n             */\n            Decimal.decimal memory tollFees = fees.divScalar(2);\n            Decimal.decimal memory spreadFees = fees.subD(tollFees);\n\n            _transferFrom(quoteToken, _from, address(this), tollFees);\n            tollMap[address(quoteToken)] = tollMap[address(quoteToken)].addD(\n                tollFees\n            );\n\n            _transferFrom(\n                quoteToken,\n                _from,\n                address(insuranceFund),\n                spreadFees\n            );\n        }\n    }\n\n    function _withdraw(\n        IERC20 _token,\n        address _receiver,\n        Decimal.decimal memory _amount\n    ) internal {\n        // token balance (without toll fees)\n        Decimal.decimal memory tollTotal = tollMap[address(_token)];\n        Decimal.decimal memory totalTokenBalance = _balanceOf(\n            _token,\n            address(this)\n        ).subD(tollTotal);\n        // if token balance is less than withdrawal amount, use toll to cover deficit\n        // if toll balance is still insufficient, borrow from insurance fund\n        if (totalTokenBalance.toUint() < _amount.toUint()) {\n            Decimal.decimal memory balanceShortage = _amount.subD(\n                totalTokenBalance\n            );\n            Decimal.decimal memory tollShortage = _coverWithToll(\n                _token,\n                balanceShortage\n            );\n            if (tollShortage.toUint() > 0) {\n                insuranceFund.withdraw(_token, tollShortage);\n            }\n        }\n\n        _transfer(_token, _receiver, _amount);\n    }\n\n    function _coverWithToll(\n        IERC20 _token,\n        Decimal.decimal memory _amount\n    ) internal returns (Decimal.decimal memory tollShortage) {\n        Decimal.decimal memory tollTotal = tollMap[address(_token)];\n        if (tollTotal.toUint() > _amount.toUint()) {\n            tollMap[address(_token)] = tollTotal.subD(_amount);\n        } else {\n            tollShortage = _amount.subD(tollTotal);\n            tollMap[address(_token)] = Decimal.zero();\n        }\n    }\n\n    function _settleRepegPnl(\n        IAmm _amm,\n        SignedDecimal.signedDecimal memory _repegPnl\n    ) internal returns (Decimal.decimal memory repegDebt) {\n        if (_repegPnl.toInt() != 0) {\n            Decimal.decimal memory repegPnlAbs = _repegPnl.abs();\n            IERC20 token = _amm.quoteAsset();\n            // settle pnl with insurance fund\n            if (_repegPnl.isNegative()) {\n                // use toll to cover repeg loss\n                // if toll is not enough, borrow deficit from insurance fund\n                repegDebt = _coverWithToll(token, repegPnlAbs);\n                if (repegDebt.toUint() > 0) {\n                    insuranceFund.withdraw(token, repegDebt);\n                }\n            } else {\n                // transfer to insurance fund\n                _transferToInsuranceFund(token, repegPnlAbs);\n            }\n        }\n    }\n\n    function _transferToInsuranceFund(\n        IERC20 _token,\n        Decimal.decimal memory _amount\n    ) internal {\n        Decimal.decimal memory totalTokenBalance = _balanceOf(\n            _token,\n            address(this)\n        );\n        Decimal.decimal memory amountToTransfer = _amount.cmp(\n            totalTokenBalance\n        ) > 0\n            ? totalTokenBalance\n            : _amount;\n        _transfer(_token, address(insuranceFund), amountToTransfer);\n    }\n\n    function _updateOpenInterestNotional(\n        IAmm _amm,\n        SignedDecimal.signedDecimal memory _amount\n    ) internal {\n        // when cap = 0 means no cap\n        uint256 openInterestNotionalCap = _amm\n            .getOpenInterestNotionalCap()\n            .toUint();\n        SignedDecimal.signedDecimal memory openInterestNotional = MixedDecimal\n            .fromDecimal(openInterestNotionalMap[address(_amm)]);\n        openInterestNotional = _amount.addD(openInterestNotional);\n        if (openInterestNotional.toInt() < 0) {\n            openInterestNotional = SignedDecimal.zero();\n        }\n        if (openInterestNotionalCap != 0) {\n            require(\n                openInterestNotional.toUint() <= openInterestNotionalCap,\n                \"over open interest cap\"\n            );\n        }\n\n        openInterestNotionalMap[address(_amm)] = openInterestNotional.abs();\n    }\n\n    function _updateTotalPositionSize(\n        IAmm _amm,\n        SignedDecimal.signedDecimal memory _amount,\n        Side _side\n    ) internal {\n        TotalPositionSize memory tps = totalPositionSizeMap[address(_amm)];\n        tps.netPositionSize = _amount.addD(tps.netPositionSize);\n        if (_side == Side.BUY) {\n            tps.positionSizeLong = _amount.addD(tps.positionSizeLong).abs();\n        } else {\n            tps.positionSizeShort = _amount\n                .mulScalar(-1)\n                .addD(tps.positionSizeShort)\n                .abs();\n        }\n        totalPositionSizeMap[address(_amm)] = tps;\n    }\n\n    function setPosition(\n        IAmm _amm,\n        address _trader,\n        Position memory _position\n    ) internal {\n        Position storage positionStorage = positionMap[address(_amm)][_trader];\n        positionStorage.size = _position.size;\n        positionStorage.margin = _position.margin;\n        positionStorage.openNotional = _position.openNotional;\n        positionStorage.lastUpdatedCumulativePremiumFractionLong = _position\n            .lastUpdatedCumulativePremiumFractionLong;\n        positionStorage.lastUpdatedCumulativePremiumFractionShort = _position\n            .lastUpdatedCumulativePremiumFractionShort;\n        positionStorage.blockNumber = _position.blockNumber;\n    }\n\n    function _clearPosition(IAmm _amm, address _trader) internal {\n        // keep the record in order to retain the last updated block number\n        positionMap[address(_amm)][_trader] = Position({\n            size: SignedDecimal.zero(),\n            margin: Decimal.zero(),\n            openNotional: Decimal.zero(),\n            lastUpdatedCumulativePremiumFractionLong: SignedDecimal.zero(),\n            lastUpdatedCumulativePremiumFractionShort: SignedDecimal.zero(),\n            blockNumber: block.number\n        });\n    }\n\n    function _calcRemainMarginWithFundingPayment(\n        IAmm _amm,\n        Position memory _oldPosition,\n        SignedDecimal.signedDecimal memory _marginDelta\n    )\n        internal\n        view\n        returns (\n            CalcRemainMarginReturnParams memory calcRemainMarginReturnParams\n        )\n    {\n        // calculate funding payment\n        (\n            calcRemainMarginReturnParams.latestCumulativePremiumFractionLong,\n            calcRemainMarginReturnParams.latestCumulativePremiumFractionShort\n        ) = getLatestCumulativePremiumFraction(_amm);\n\n        if (_oldPosition.size.toInt() != 0) {\n            if (_oldPosition.size.toInt() > 0) {\n                calcRemainMarginReturnParams\n                    .fundingPayment = calcRemainMarginReturnParams\n                    .latestCumulativePremiumFractionLong\n                    .subD(_oldPosition.lastUpdatedCumulativePremiumFractionLong)\n                    .mulD(_oldPosition.size);\n            } else {\n                calcRemainMarginReturnParams\n                    .fundingPayment = calcRemainMarginReturnParams\n                    .latestCumulativePremiumFractionShort\n                    .subD(\n                        _oldPosition.lastUpdatedCumulativePremiumFractionShort\n                    )\n                    .mulD(_oldPosition.size);\n            }\n        }\n\n        // calculate remain margin\n        SignedDecimal.signedDecimal memory signedRemainMargin = _marginDelta\n            .subD(calcRemainMarginReturnParams.fundingPayment)\n            .addD(_oldPosition.margin);\n\n        // if remain margin is negative, set to zero and leave the rest to bad debt\n        if (signedRemainMargin.toInt() < 0) {\n            calcRemainMarginReturnParams.badDebt = signedRemainMargin.abs();\n        } else {\n            calcRemainMarginReturnParams.remainingMargin = signedRemainMargin\n                .abs();\n        }\n    }\n\n    function _calcFreeCollateral(\n        IAmm _amm,\n        address _trader,\n        Decimal.decimal memory _marginWithFundingPayment\n    ) internal view returns (SignedDecimal.signedDecimal memory) {\n        Position memory pos = getPosition(_amm, _trader);\n        (\n            Decimal.decimal memory positionNotional,\n            SignedDecimal.signedDecimal memory unrealizedPnl\n        ) = getPositionNotionalAndUnrealizedPnl(\n                _amm,\n                _trader,\n                PnlCalcOption.SPOT_PRICE\n            );\n\n        // min(margin + funding, margin + funding + unrealized PnL) - position value * initMarginRatio\n        SignedDecimal.signedDecimal memory accountValue = unrealizedPnl.addD(\n            _marginWithFundingPayment\n        );\n        SignedDecimal.signedDecimal memory minCollateral = unrealizedPnl\n            .toInt() > 0\n            ? MixedDecimal.fromDecimal(_marginWithFundingPayment)\n            : accountValue;\n\n        // margin requirement\n        // if holding a long position, using open notional\n        // if holding a short position, using position notional\n        Decimal.decimal memory initMarginRatio = _amm\n            .getRatios()\n            .initMarginRatio;\n        SignedDecimal.signedDecimal memory marginRequirement = pos\n            .size\n            .toInt() > 0\n            ? MixedDecimal.fromDecimal(pos.openNotional).mulD(initMarginRatio)\n            : MixedDecimal.fromDecimal(positionNotional).mulD(initMarginRatio);\n\n        return minCollateral.subD(marginRequirement);\n    }\n\n    function _getMarginRatioByCalcOption(\n        IAmm _amm,\n        address _trader,\n        PnlCalcOption _pnlCalcOption\n    ) internal view returns (SignedDecimal.signedDecimal memory) {\n        Position memory position = getPosition(_amm, _trader);\n        _requirePositionSize(position.size);\n        (\n            Decimal.decimal memory positionNotional,\n            SignedDecimal.signedDecimal memory pnl\n        ) = getPositionNotionalAndUnrealizedPnl(_amm, _trader, _pnlCalcOption);\n        return _getMarginRatio(_amm, position, pnl, positionNotional);\n    }\n\n    function _requireAmm(IAmm _amm) internal view {\n        require(insuranceFund.isExistedAmm(_amm), \"amm not found\");\n    }\n\n    function _requireNonZeroInput(\n        Decimal.decimal memory _decimal\n    ) internal pure {\n        require(_decimal.toUint() != 0, \"0 input\");\n    }\n\n    function _requirePositionSize(\n        SignedDecimal.signedDecimal memory _size\n    ) internal pure {\n        require(_size.toInt() != 0, \"positionSize is 0\");\n    }\n\n    function _requireNonSandwich(IAmm _amm) internal view {\n        uint256 currentBlock = block.number;\n        require(\n            getPosition(_amm, _msgSender()).blockNumber != currentBlock,\n            \"non sandwich\"\n        );\n    }\n\n    function _requireMoreMarginRatio(\n        SignedDecimal.signedDecimal memory _marginRatio,\n        Decimal.decimal memory _baseMarginRatio,\n        bool _largerThanOrEqualTo\n    ) internal pure {\n        int256 remainingMarginRatio = _marginRatio\n            .subD(_baseMarginRatio)\n            .toInt();\n        require(\n            _largerThanOrEqualTo\n                ? remainingMarginRatio >= 0\n                : remainingMarginRatio < 0,\n            \"margin ratio not meet critera\"\n        );\n    }\n}\n"
    },
    "contracts/InsuranceFund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\npragma experimental ABIEncoderV2;\n\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"./utils/Decimal.sol\";\nimport {IExchangeWrapper} from \"./interfaces/IExchangeWrapper.sol\";\nimport {IInsuranceFund} from \"./interfaces/IInsuranceFund.sol\";\nimport {DecimalERC20} from \"./utils/DecimalERC20.sol\";\nimport {IMinter} from \"./interfaces/IMinter.sol\";\nimport {IAmm} from \"./interfaces/IAmm.sol\";\nimport {IInflationMonitor} from \"./interfaces/IInflationMonitor.sol\";\n\ncontract InsuranceFund is\n    IInsuranceFund,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable,\n    DecimalERC20\n{\n    using Decimal for Decimal.decimal;\n\n    //\n    // EVENTS\n    //\n\n    event Withdrawn(address withdrawer, uint256 amount);\n    event TokenAdded(address tokenAddress);\n    event TokenRemoved(address tokenAddress);\n    event ShutdownAllAmms(uint256 blockNumber);\n    event AmmAdded(address amm);\n    event AmmRemoved(address amm);\n\n    //**********************************************************//\n    //    The below state variables can not change the order    //\n    //**********************************************************//\n\n    mapping(address => bool) private ammMap;\n    mapping(address => bool) private quoteTokenMap;\n    IAmm[] private amms;\n    IERC20[] public quoteTokens;\n\n    // contract dependencies\n    IExchangeWrapper public exchange;\n    IERC20 public perpToken;\n    IMinter public minter;\n    IInflationMonitor public inflationMonitor;\n    address private beneficiary;\n\n    //**********************************************************//\n    //    The above state variables can not change the order    //\n    //**********************************************************//\n\n    // add state variables below //\n\n    // add state variables above //\n    uint256[50] private __gap;\n\n    //\n    // FUNCTIONS\n    //\n\n    function initialize() external initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n    }\n\n    /**\n     * @dev only owner can call\n     * @param _amm IAmm address\n     */\n    function addAmm(IAmm _amm) public onlyOwner {\n        require(!isExistedAmm(_amm), \"amm already added\");\n        ammMap[address(_amm)] = true;\n        amms.push(_amm);\n        emit AmmAdded(address(_amm));\n\n        // add token if it's new one\n        IERC20 token = _amm.quoteAsset();\n        if (!isQuoteTokenExisted(token)) {\n            quoteTokens.push(token);\n            quoteTokenMap[address(token)] = true;\n            emit TokenAdded(address(token));\n        }\n    }\n\n    /**\n     * @dev only owner can call. no need to call\n     * @param _amm IAmm address\n     */\n    function removeAmm(IAmm _amm) external onlyOwner {\n        require(isExistedAmm(_amm), \"amm not existed\");\n        ammMap[address(_amm)] = false;\n        uint256 ammLength = amms.length;\n        for (uint256 i = 0; i < ammLength; i++) {\n            if (amms[i] == _amm) {\n                amms[i] = amms[ammLength - 1];\n                amms.pop();\n                emit AmmRemoved(address(_amm));\n                break;\n            }\n        }\n    }\n\n    function removeToken(IERC20 _token) external onlyOwner {\n        require(isQuoteTokenExisted(_token), \"token not existed\");\n\n        quoteTokenMap[address(_token)] = false;\n        uint256 quoteTokensLength = getQuoteTokenLength();\n        for (uint256 i = 0; i < quoteTokensLength; i++) {\n            if (quoteTokens[i] == _token) {\n                if (i < quoteTokensLength - 1) {\n                    quoteTokens[i] = quoteTokens[quoteTokensLength - 1];\n                }\n                quoteTokens.pop();\n                break;\n            }\n        }\n\n        // exchange and transfer to the quoteToken with the most value. if no more quoteToken, buy protocol tokens\n        // TODO use curve or balancer fund token for pooling the fees will be less painful\n        if (balanceOf(_token).toUint() > 0) {\n            address outputToken = getTokenWithMaxValue();\n            if (outputToken == address(0)) {\n                outputToken = address(perpToken);\n            }\n            swapInput(\n                _token,\n                IERC20(outputToken),\n                balanceOf(_token),\n                Decimal.zero()\n            );\n        }\n\n        emit TokenRemoved(address(_token));\n    }\n\n    /**\n     * @notice withdraw token to caller\n     * @param _amount the amount of quoteToken caller want to withdraw\n     */\n    function withdraw(\n        IERC20 _quoteToken,\n        Decimal.decimal calldata _amount\n    ) external override {\n        require(beneficiary == _msgSender(), \"caller is not beneficiary\");\n        require(isQuoteTokenExisted(_quoteToken), \"Asset is not supported\");\n\n        Decimal.decimal memory quoteBalance = balanceOf(_quoteToken);\n        if (_amount.toUint() > quoteBalance.toUint()) {\n            Decimal.decimal memory insufficientAmount = _amount.subD(\n                quoteBalance\n            );\n            swapEnoughQuoteAmount(_quoteToken, insufficientAmount);\n            quoteBalance = balanceOf(_quoteToken);\n        }\n        require(quoteBalance.toUint() >= _amount.toUint(), \"Fund not enough\");\n\n        _transfer(_quoteToken, _msgSender(), _amount);\n        emit Withdrawn(_msgSender(), _amount.toUint());\n    }\n\n    //\n    // SETTER\n    //\n\n    function setExchange(IExchangeWrapper _exchange) external onlyOwner {\n        exchange = _exchange;\n    }\n\n    function setBeneficiary(address _beneficiary) external onlyOwner {\n        beneficiary = _beneficiary;\n    }\n\n    function setMinter(IMinter _minter) public onlyOwner {\n        minter = _minter;\n        perpToken = minter.getPerpToken();\n    }\n\n    function setInflationMonitor(\n        IInflationMonitor _inflationMonitor\n    ) external onlyOwner {\n        inflationMonitor = _inflationMonitor;\n    }\n\n    function getQuoteTokenLength() public view returns (uint256) {\n        return quoteTokens.length;\n    }\n\n    //\n    // INTERNAL FUNCTIONS\n    //\n\n    function getTokenWithMaxValue() internal view returns (address) {\n        uint256 numOfQuoteTokens = quoteTokens.length;\n        if (numOfQuoteTokens == 0) {\n            return address(0);\n        }\n        if (numOfQuoteTokens == 1) {\n            return address(quoteTokens[0]);\n        }\n\n        IERC20 denominatedToken = quoteTokens[0];\n        IERC20 maxValueToken = denominatedToken;\n        Decimal.decimal memory valueOfMaxValueToken = balanceOf(\n            denominatedToken\n        );\n        for (uint256 i = 1; i < numOfQuoteTokens; i++) {\n            IERC20 quoteToken = quoteTokens[i];\n            Decimal.decimal memory quoteTokenValue = exchange.getInputPrice(\n                quoteToken,\n                denominatedToken,\n                balanceOf(quoteToken)\n            );\n            if (quoteTokenValue.cmp(valueOfMaxValueToken) > 0) {\n                maxValueToken = quoteToken;\n                valueOfMaxValueToken = quoteTokenValue;\n            }\n        }\n        return address(maxValueToken);\n    }\n\n    function swapInput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal memory inputTokenSold,\n        Decimal.decimal memory minOutputTokenBought\n    ) internal returns (Decimal.decimal memory received) {\n        if (inputTokenSold.toUint() == 0) {\n            return Decimal.zero();\n        }\n        _approve(inputToken, address(exchange), inputTokenSold);\n        received = exchange.swapInput(\n            inputToken,\n            outputToken,\n            inputTokenSold,\n            minOutputTokenBought,\n            Decimal.zero()\n        );\n        require(received.toUint() > 0, \"Exchange swap error\");\n    }\n\n    function swapOutput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal memory outputTokenBought,\n        Decimal.decimal memory maxInputTokenSold\n    ) internal returns (Decimal.decimal memory received) {\n        if (outputTokenBought.toUint() == 0) {\n            return Decimal.zero();\n        }\n        _approve(inputToken, address(exchange), maxInputTokenSold);\n        received = exchange.swapOutput(\n            inputToken,\n            outputToken,\n            outputTokenBought,\n            maxInputTokenSold,\n            Decimal.zero()\n        );\n        require(received.toUint() > 0, \"Exchange swap error\");\n    }\n\n    function swapEnoughQuoteAmount(\n        IERC20 _quoteToken,\n        Decimal.decimal memory _requiredQuoteAmount\n    ) internal {\n        IERC20[] memory orderedTokens = getOrderedQuoteTokens(_quoteToken);\n        for (uint256 i = 0; i < orderedTokens.length; i++) {\n            // get how many amount of quote token i is still required\n            Decimal.decimal memory swappedQuoteToken;\n            Decimal.decimal memory otherQuoteRequiredAmount = exchange\n                .getOutputPrice(\n                    orderedTokens[i],\n                    _quoteToken,\n                    _requiredQuoteAmount\n                );\n\n            // if balance of token i can afford the left debt, swap and return\n            if (\n                otherQuoteRequiredAmount.toUint() <=\n                balanceOf(orderedTokens[i]).toUint()\n            ) {\n                swappedQuoteToken = swapInput(\n                    orderedTokens[i],\n                    _quoteToken,\n                    otherQuoteRequiredAmount,\n                    Decimal.zero()\n                );\n                return;\n            }\n\n            // if balance of token i can't afford the left debt, show hand and move to the next one\n            swappedQuoteToken = swapInput(\n                orderedTokens[i],\n                _quoteToken,\n                balanceOf(orderedTokens[i]),\n                Decimal.zero()\n            );\n            _requiredQuoteAmount = _requiredQuoteAmount.subD(swappedQuoteToken);\n        }\n\n        // if all the quote tokens can't afford the debt, ask staking token to mint\n        if (_requiredQuoteAmount.toUint() > 0) {\n            Decimal.decimal memory requiredPerpAmount = exchange.getOutputPrice(\n                perpToken,\n                _quoteToken,\n                _requiredQuoteAmount\n            );\n            minter.mintForLoss(requiredPerpAmount);\n            swapInput(\n                perpToken,\n                _quoteToken,\n                requiredPerpAmount,\n                Decimal.zero()\n            );\n        }\n    }\n\n    //\n    // VIEW\n    //\n    function isExistedAmm(IAmm _amm) public view override returns (bool) {\n        return ammMap[address(_amm)];\n    }\n\n    function getAllAmms() external view override returns (IAmm[] memory) {\n        return amms;\n    }\n\n    function isQuoteTokenExisted(IERC20 _token) internal view returns (bool) {\n        return quoteTokenMap[address(_token)];\n    }\n\n    function getOrderedQuoteTokens(\n        IERC20 _exceptionQuoteToken\n    ) internal view returns (IERC20[] memory orderedTokens) {\n        IERC20[] memory tokens = quoteTokens;\n        // insertion sort\n        for (uint256 i = 0; i < getQuoteTokenLength(); i++) {\n            IERC20 currentToken = quoteTokens[i];\n            Decimal.decimal memory currentPerpValue = exchange.getInputPrice(\n                currentToken,\n                perpToken,\n                balanceOf(currentToken)\n            );\n\n            for (uint256 j = i; j > 0; j--) {\n                Decimal.decimal memory subsetPerpValue = exchange.getInputPrice(\n                    tokens[j - 1],\n                    perpToken,\n                    balanceOf(tokens[j - 1])\n                );\n                if (currentPerpValue.toUint() > subsetPerpValue.toUint()) {\n                    tokens[j] = tokens[j - 1];\n                    tokens[j - 1] = currentToken;\n                }\n            }\n        }\n\n        orderedTokens = new IERC20[](tokens.length - 1);\n        uint256 j;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            // jump to the next token\n            if (tokens[i] == _exceptionQuoteToken) {\n                continue;\n            }\n            orderedTokens[j] = tokens[i];\n            j++;\n        }\n    }\n\n    function balanceOf(\n        IERC20 _quoteToken\n    ) internal view returns (Decimal.decimal memory) {\n        return _balanceOf(_quoteToken, address(this));\n    }\n}\n"
    },
    "contracts/interfaces/IAmm.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\nimport {SignedDecimal} from \"../utils/SignedDecimal.sol\";\n\ninterface IAmm {\n    /**\n     * @notice asset direction, used in getInputPrice, getOutputPrice, swapInput and swapOutput\n     * @param ADD_TO_AMM add asset to Amm\n     * @param REMOVE_FROM_AMM remove asset from Amm\n     */\n    enum Dir {\n        ADD_TO_AMM,\n        REMOVE_FROM_AMM\n    }\n\n    struct Ratios {\n        Decimal.decimal feeRatio;\n        Decimal.decimal initMarginRatio;\n        Decimal.decimal maintenanceMarginRatio;\n        Decimal.decimal partialLiquidationRatio;\n        Decimal.decimal liquidationFeeRatio;\n    }\n\n    function swapInput(\n        Dir _dirOfQuote,\n        Decimal.decimal calldata _quoteAssetAmount,\n        Decimal.decimal calldata _baseAssetAmountLimit,\n        bool _canOverFluctuationLimit\n    ) external returns (Decimal.decimal memory);\n\n    function swapOutput(\n        Dir _dirOfBase,\n        Decimal.decimal calldata _baseAssetAmount,\n        Decimal.decimal calldata _quoteAssetAmountLimit\n    ) external returns (Decimal.decimal memory);\n\n    function settleFunding()\n        external\n        returns (\n            SignedDecimal.signedDecimal memory premiumFraction,\n            Decimal.decimal memory markPrice,\n            Decimal.decimal memory indexPrice\n        );\n\n    function repegPrice()\n        external\n        returns (\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            SignedDecimal.signedDecimal memory\n        );\n\n    function repegK(\n        Decimal.decimal memory _multiplier\n    )\n        external\n        returns (\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            Decimal.decimal memory,\n            SignedDecimal.signedDecimal memory\n        );\n\n    function updateFundingRate(\n        SignedDecimal.signedDecimal memory,\n        SignedDecimal.signedDecimal memory,\n        Decimal.decimal memory\n    ) external;\n\n    //\n    // VIEW\n    //\n\n    function calcFee(\n        Dir _dirOfQuote,\n        Decimal.decimal calldata _quoteAssetAmount,\n        bool _isOpenPos\n    ) external view returns (Decimal.decimal memory fees);\n\n    function getMarkPrice() external view returns (Decimal.decimal memory);\n\n    function getIndexPrice() external view returns (Decimal.decimal memory);\n\n    function getReserves()\n        external\n        view\n        returns (Decimal.decimal memory, Decimal.decimal memory);\n\n    function getFeeRatio() external view returns (Decimal.decimal memory);\n\n    function getInitMarginRatio()\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getMaintenanceMarginRatio()\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getPartialLiquidationRatio()\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getLiquidationFeeRatio()\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getMaxHoldingBaseAsset()\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getOpenInterestNotionalCap()\n        external\n        view\n        returns (Decimal.decimal memory);\n\n    function getBaseAssetDelta()\n        external\n        view\n        returns (SignedDecimal.signedDecimal memory);\n\n    function getCumulativeNotional()\n        external\n        view\n        returns (SignedDecimal.signedDecimal memory);\n\n    function fundingPeriod() external view returns (uint256);\n\n    function quoteAsset() external view returns (IERC20);\n\n    function open() external view returns (bool);\n\n    function getRatios() external view returns (Ratios memory);\n\n    function calcPriceRepegPnl(\n        Decimal.decimal memory _repegTo\n    ) external view returns (SignedDecimal.signedDecimal memory repegPnl);\n\n    function calcKRepegPnl(\n        Decimal.decimal memory _k\n    ) external view returns (SignedDecimal.signedDecimal memory repegPnl);\n\n    function isOverFluctuationLimit(\n        Dir _dirOfBase,\n        Decimal.decimal memory _baseAssetAmount\n    ) external view returns (bool);\n\n    function isOverSpreadLimit() external view returns (bool);\n\n    function getInputTwap(\n        Dir _dir,\n        Decimal.decimal calldata _quoteAssetAmount\n    ) external view returns (Decimal.decimal memory);\n\n    function getOutputTwap(\n        Dir _dir,\n        Decimal.decimal calldata _baseAssetAmount\n    ) external view returns (Decimal.decimal memory);\n\n    function getInputPrice(\n        Dir _dir,\n        Decimal.decimal calldata _quoteAssetAmount\n    ) external view returns (Decimal.decimal memory);\n\n    function getOutputPrice(\n        Dir _dir,\n        Decimal.decimal calldata _baseAssetAmount\n    ) external view returns (Decimal.decimal memory);\n\n    function getInputPriceWithReserves(\n        Dir _dir,\n        Decimal.decimal memory _quoteAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) external view returns (Decimal.decimal memory);\n\n    function getOutputPriceWithReserves(\n        Dir _dir,\n        Decimal.decimal memory _baseAssetAmount,\n        Decimal.decimal memory _quoteAssetPoolAmount,\n        Decimal.decimal memory _baseAssetPoolAmount\n    ) external view returns (Decimal.decimal memory);\n}\n"
    },
    "contracts/interfaces/IExchangeWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../utils/Decimal.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IExchangeWrapper {\n    function swapInput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata inputTokenSold,\n        Decimal.decimal calldata minOutputTokenBought,\n        Decimal.decimal calldata maxPrice\n    ) external returns (Decimal.decimal memory);\n\n    function swapOutput(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata outputTokenBought,\n        Decimal.decimal calldata maxInputTokeSold,\n        Decimal.decimal calldata maxPrice\n    ) external returns (Decimal.decimal memory);\n\n    function getInputPrice(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata inputTokenSold\n    ) external view returns (Decimal.decimal memory);\n\n    function getOutputPrice(\n        IERC20 inputToken,\n        IERC20 outputToken,\n        Decimal.decimal calldata outputTokenBought\n    ) external view returns (Decimal.decimal memory);\n\n    function getSpotPrice(\n        IERC20 inputToken,\n        IERC20 outputToken\n    ) external view returns (Decimal.decimal memory);\n}\n"
    },
    "contracts/interfaces/IInflationMonitor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\npragma experimental ABIEncoderV2;\n\nimport {Decimal} from \"../utils/Decimal.sol\";\n\ninterface IInflationMonitor {\n    function isOverMintThreshold() external view returns (bool);\n\n    function appendMintedTokenHistory(\n        Decimal.decimal calldata _amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IInsuranceFund.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\nimport {IAmm} from \"./IAmm.sol\";\n\ninterface IInsuranceFund {\n    function withdraw(\n        IERC20 _quoteToken,\n        Decimal.decimal calldata _amount\n    ) external;\n\n    function isExistedAmm(IAmm _amm) external view returns (bool);\n\n    function getAllAmms() external view returns (IAmm[] memory);\n}\n"
    },
    "contracts/interfaces/IMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"../utils/Decimal.sol\";\n\ninterface IMinter {\n    function mintReward() external;\n\n    function mintForLoss(Decimal.decimal memory _amount) external;\n\n    function getPerpToken() external view returns (IERC20);\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\ninterface IPriceFeed {\n    // get latest price\n    function getPrice(bytes32 _priceFeedKey) external view returns (uint256);\n}\n"
    },
    "contracts/OwnerPausable.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {PausableUpgradeable} from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract OwnerPausableUpgradeable is OwnableUpgradeable, PausableUpgradeable {\n    // add state variables below //\n\n    // add state variables above //\n    uint256[50] private __gap;\n\n    // solhint-disable func-name-mixedcase\n    function __OwnerPausable_init() internal onlyInitializing {\n        __Ownable_init();\n        __Pausable_init();\n    }\n\n    /**\n     * @notice pauses trading\n     * @dev only owner\n     */\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice resumes trading\n     * @dev only owner\n     */\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n}\n"
    },
    "contracts/utils/BlockContext.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\n// wrap block.xxx functions for testing\n// only support timestamp and number so far\nabstract contract BlockContext {\n    // add state variables below //\n\n    // add state variables above //\n    uint256[50] private __gap;\n\n    function _blockTimestamp() internal view virtual returns (uint256) {\n        return block.timestamp;\n    }\n\n    function _blockNumber() internal view virtual returns (uint256) {\n        return block.number;\n    }\n}\n"
    },
    "contracts/utils/Decimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {DecimalMath} from \"./DecimalMath.sol\";\n\nlibrary Decimal {\n    using DecimalMath for uint256;\n\n    struct decimal {\n        uint256 d;\n    }\n\n    function zero() internal pure returns (decimal memory) {\n        return decimal(0);\n    }\n\n    function one() internal pure returns (decimal memory) {\n        return decimal(DecimalMath.unit(18));\n    }\n\n    function toUint(decimal memory x) internal pure returns (uint256) {\n        return x.d;\n    }\n\n    function modD(\n        decimal memory x,\n        decimal memory y\n    ) internal pure returns (decimal memory) {\n        return decimal((x.d * (DecimalMath.unit(18))) % y.d);\n    }\n\n    function cmp(\n        decimal memory x,\n        decimal memory y\n    ) internal pure returns (int8) {\n        if (x.d > y.d) {\n            return 1;\n        } else if (x.d < y.d) {\n            return -1;\n        }\n        return 0;\n    }\n\n    /// @dev add two decimals\n    function addD(\n        decimal memory x,\n        decimal memory y\n    ) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.addd(y.d);\n        return t;\n    }\n\n    /// @dev subtract two decimals\n    function subD(\n        decimal memory x,\n        decimal memory y\n    ) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.subd(y.d);\n        return t;\n    }\n\n    /// @dev multiple two decimals\n    function mulD(\n        decimal memory x,\n        decimal memory y\n    ) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.muld(y.d);\n        return t;\n    }\n\n    /// @dev multiple a decimal by a uint256\n    function mulScalar(\n        decimal memory x,\n        uint256 y\n    ) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d * y;\n        return t;\n    }\n\n    /// @dev divide two decimals\n    function divD(\n        decimal memory x,\n        decimal memory y\n    ) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d.divd(y.d);\n        return t;\n    }\n\n    /// @dev divide a decimal by a uint256\n    function divScalar(\n        decimal memory x,\n        uint256 y\n    ) internal pure returns (decimal memory) {\n        decimal memory t;\n        t.d = x.d / y;\n        return t;\n    }\n\n    /// @dev square root\n    function sqrt(decimal memory _y) internal pure returns (decimal memory) {\n        uint256 y = _y.d * 1e18;\n        uint256 z;\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        return decimal(z);\n    }\n}\n"
    },
    "contracts/utils/DecimalERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Decimal} from \"./Decimal.sol\";\n\n/**\n * @title DecimalERC20\n * @notice wrapper to interact with erc20 in decimal math\n */\nabstract contract DecimalERC20 {\n    using Decimal for Decimal.decimal;\n\n    mapping(address => uint256) private decimalMap;\n\n    // add state variables below //\n\n    // add state variables above //\n\n    uint256[50] private __gap;\n\n    function _transfer(\n        IERC20 _token,\n        address _to,\n        Decimal.decimal memory _value\n    ) internal {\n        _updateDecimal(address(_token));\n        Decimal.decimal memory balanceBefore = _balanceOf(_token, _to);\n        uint256 rawValue = _toUint(_token, _value);\n        require(_token.transfer(_to, rawValue), \"transfer failed\");\n        _validateBalance(_token, _to, rawValue, balanceBefore);\n    }\n\n    function _transferFrom(\n        IERC20 _token,\n        address _from,\n        address _to,\n        Decimal.decimal memory _value\n    ) internal {\n        _updateDecimal(address(_token));\n        Decimal.decimal memory balanceBefore = _balanceOf(_token, _to);\n        uint256 rawValue = _toUint(_token, _value);\n        require(\n            _token.transferFrom(_from, _to, rawValue),\n            \"transferFrom failed\"\n        );\n        _validateBalance(_token, _to, rawValue, balanceBefore);\n    }\n\n    function _approve(\n        IERC20 _token,\n        address _spender,\n        Decimal.decimal memory _value\n    ) internal {\n        _updateDecimal(address(_token));\n        // to be compatible with some erc20 tokens like USDT\n        __approve(_token, _spender, Decimal.zero());\n        __approve(_token, _spender, _value);\n    }\n\n    //\n    // VIEW\n    //\n    function _allowance(\n        IERC20 _token,\n        address _owner,\n        address _spender\n    ) internal view returns (Decimal.decimal memory) {\n        return _toDecimal(_token, _token.allowance(_owner, _spender));\n    }\n\n    function _balanceOf(\n        IERC20 _token,\n        address _owner\n    ) internal view returns (Decimal.decimal memory) {\n        return _toDecimal(_token, _token.balanceOf(_owner));\n    }\n\n    function _totalSupply(\n        IERC20 _token\n    ) internal view returns (Decimal.decimal memory) {\n        return _toDecimal(_token, _token.totalSupply());\n    }\n\n    function _toDecimal(\n        IERC20 _token,\n        uint256 _number\n    ) internal view returns (Decimal.decimal memory) {\n        uint256 tokenDecimals = _getTokenDecimals(address(_token));\n        if (tokenDecimals >= 18) {\n            return Decimal.decimal(_number / (10 ** (tokenDecimals - 18)));\n        }\n\n        return Decimal.decimal(_number * (10 ** (uint256(18) - tokenDecimals)));\n    }\n\n    function _toUint(\n        IERC20 _token,\n        Decimal.decimal memory _decimal\n    ) internal view returns (uint256) {\n        uint256 tokenDecimals = _getTokenDecimals(address(_token));\n        if (tokenDecimals >= 18) {\n            return _decimal.toUint() * (10 ** (tokenDecimals - 18));\n        }\n        return _decimal.toUint() / (10 ** (uint256(18) - tokenDecimals));\n    }\n\n    function _getTokenDecimals(address _token) internal view returns (uint256) {\n        uint256 tokenDecimals = decimalMap[_token];\n        if (tokenDecimals == 0) {\n            (bool success, bytes memory data) = _token.staticcall(\n                abi.encodeWithSignature(\"decimals()\")\n            );\n            require(success && data.length != 0, \"get decimals failed\");\n            tokenDecimals = abi.decode(data, (uint256));\n        }\n        return tokenDecimals;\n    }\n\n    //\n    // PRIVATE\n    //\n    function _updateDecimal(address _token) private {\n        uint256 tokenDecimals = _getTokenDecimals(_token);\n        if (decimalMap[_token] != tokenDecimals) {\n            decimalMap[_token] = tokenDecimals;\n        }\n    }\n\n    function __approve(\n        IERC20 _token,\n        address _spender,\n        Decimal.decimal memory _value\n    ) private {\n        require(\n            _token.approve(_spender, _toUint(_token, _value)),\n            \"approve failed\"\n        );\n    }\n\n    // To prevent from deflationary token, check receiver's balance is as expectation.\n    function _validateBalance(\n        IERC20 _token,\n        address _to,\n        uint256 _roundedDownValue,\n        Decimal.decimal memory _balanceBefore\n    ) private view {\n        require(\n            _balanceOf(_token, _to).cmp(\n                _balanceBefore.addD(_toDecimal(_token, _roundedDownValue))\n            ) == 0,\n            \"balance inconsistent\"\n        );\n    }\n}\n"
    },
    "contracts/utils/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nlibrary DecimalMath {\n    /// @dev Returns 1 in the fixed point representation, with `decimals` decimals.\n    function unit(uint8 decimals) internal pure returns (uint256) {\n        return 10 ** uint256(decimals);\n    }\n\n    /// @dev Adds x and y, assuming they are both fixed point with 18 decimals.\n    function addd(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x + y;\n    }\n\n    /// @dev Subtracts y from x, assuming they are both fixed point with 18 decimals.\n    function subd(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x - y;\n    }\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with 18 digits.\n    function muld(uint256 x, uint256 y) internal pure returns (uint256) {\n        return muld(x, y, 18);\n    }\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with `decimals` digits.\n    function muld(\n        uint256 x,\n        uint256 y,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        return (x * y) / (unit(decimals));\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with 18 digits.\n    function divd(uint256 x, uint256 y) internal pure returns (uint256) {\n        return divd(x, y, 18);\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with `decimals` digits.\n    function divd(\n        uint256 x,\n        uint256 y,\n        uint8 decimals\n    ) internal pure returns (uint256) {\n        return (x * unit(decimals)) / (y);\n    }\n}\n"
    },
    "contracts/utils/MixedDecimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {Decimal} from \"./Decimal.sol\";\nimport {SignedDecimal} from \"./SignedDecimal.sol\";\n\n/// @dev To handle a signedDecimal add/sub/mul/div a decimal and provide convert decimal to signedDecimal helper\nlibrary MixedDecimal {\n    using SignedDecimal for SignedDecimal.signedDecimal;\n\n    uint256 private constant _INT256_MAX = 2 ** 255 - 1;\n    string private constant ERROR_NON_CONVERTIBLE =\n        \"MixedDecimal: uint value is bigger than _INT256_MAX\";\n\n    modifier convertible(Decimal.decimal memory x) {\n        require(_INT256_MAX >= x.d, ERROR_NON_CONVERTIBLE);\n        _;\n    }\n\n    function fromDecimal(\n        Decimal.decimal memory x\n    )\n        internal\n        pure\n        convertible(x)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        return SignedDecimal.signedDecimal(int256(x.d));\n    }\n\n    function toUint(\n        SignedDecimal.signedDecimal memory x\n    ) internal pure returns (uint256) {\n        return x.abs().d;\n    }\n\n    /// @dev add SignedDecimal.signedDecimal and Decimal.decimal, using SignedSafeMath directly\n    function addD(\n        SignedDecimal.signedDecimal memory x,\n        Decimal.decimal memory y\n    )\n        internal\n        pure\n        convertible(y)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        SignedDecimal.signedDecimal memory t;\n        t.d = x.d + int256(y.d);\n        return t;\n    }\n\n    /// @dev subtract SignedDecimal.signedDecimal by Decimal.decimal, using SignedSafeMath directly\n    function subD(\n        SignedDecimal.signedDecimal memory x,\n        Decimal.decimal memory y\n    )\n        internal\n        pure\n        convertible(y)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        SignedDecimal.signedDecimal memory t;\n        t.d = x.d - int256(y.d);\n        return t;\n    }\n\n    /// @dev multiple a SignedDecimal.signedDecimal by Decimal.decimal\n    function mulD(\n        SignedDecimal.signedDecimal memory x,\n        Decimal.decimal memory y\n    )\n        internal\n        pure\n        convertible(y)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        SignedDecimal.signedDecimal memory t;\n        t = x.mulD(fromDecimal(y));\n        return t;\n    }\n\n    /// @dev multiple a SignedDecimal.signedDecimal by a uint256\n    function mulScalar(\n        SignedDecimal.signedDecimal memory x,\n        uint256 y\n    ) internal pure returns (SignedDecimal.signedDecimal memory) {\n        require(_INT256_MAX >= y, ERROR_NON_CONVERTIBLE);\n        SignedDecimal.signedDecimal memory t;\n        t = x.mulScalar(int256(y));\n        return t;\n    }\n\n    /// @dev divide a SignedDecimal.signedDecimal by a Decimal.decimal\n    function divD(\n        SignedDecimal.signedDecimal memory x,\n        Decimal.decimal memory y\n    )\n        internal\n        pure\n        convertible(y)\n        returns (SignedDecimal.signedDecimal memory)\n    {\n        SignedDecimal.signedDecimal memory t;\n        t = x.divD(fromDecimal(y));\n        return t;\n    }\n\n    /// @dev divide a SignedDecimal.signedDecimal by a uint256\n    function divScalar(\n        SignedDecimal.signedDecimal memory x,\n        uint256 y\n    ) internal pure returns (SignedDecimal.signedDecimal memory) {\n        require(_INT256_MAX >= y, ERROR_NON_CONVERTIBLE);\n        SignedDecimal.signedDecimal memory t;\n        t = x.divScalar(int256(y));\n        return t;\n    }\n}\n"
    },
    "contracts/utils/MockUSDC.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockUSDC is ERC20(\"Mock USDC\", \"USDC\") {}\n"
    },
    "contracts/utils/SignedDecimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\nimport {SignedDecimalMath} from \"./SignedDecimalMath.sol\";\nimport {Decimal} from \"./Decimal.sol\";\n\nlibrary SignedDecimal {\n    using SignedDecimalMath for int256;\n\n    struct signedDecimal {\n        int256 d;\n    }\n\n    function zero() internal pure returns (signedDecimal memory) {\n        return signedDecimal(0);\n    }\n\n    function toInt(signedDecimal memory x) internal pure returns (int256) {\n        return x.d;\n    }\n\n    function isNegative(signedDecimal memory x) internal pure returns (bool) {\n        if (x.d < 0) {\n            return true;\n        }\n        return false;\n    }\n\n    function abs(\n        signedDecimal memory x\n    ) internal pure returns (Decimal.decimal memory) {\n        Decimal.decimal memory t;\n        if (x.d < 0) {\n            t.d = uint256(0 - x.d);\n        } else {\n            t.d = uint256(x.d);\n        }\n        return t;\n    }\n\n    /// @dev add two decimals\n    function addD(\n        signedDecimal memory x,\n        signedDecimal memory y\n    ) internal pure returns (signedDecimal memory) {\n        signedDecimal memory t;\n        t.d = x.d.addd(y.d);\n        return t;\n    }\n\n    /// @dev subtract two decimals\n    function subD(\n        signedDecimal memory x,\n        signedDecimal memory y\n    ) internal pure returns (signedDecimal memory) {\n        signedDecimal memory t;\n        t.d = x.d.subd(y.d);\n        return t;\n    }\n\n    /// @dev multiple two decimals\n    function mulD(\n        signedDecimal memory x,\n        signedDecimal memory y\n    ) internal pure returns (signedDecimal memory) {\n        signedDecimal memory t;\n        t.d = x.d.muld(y.d);\n        return t;\n    }\n\n    /// @dev multiple a signedDecimal by a int256\n    function mulScalar(\n        signedDecimal memory x,\n        int256 y\n    ) internal pure returns (signedDecimal memory) {\n        signedDecimal memory t;\n        t.d = x.d * y;\n        return t;\n    }\n\n    /// @dev divide two decimals\n    function divD(\n        signedDecimal memory x,\n        signedDecimal memory y\n    ) internal pure returns (signedDecimal memory) {\n        signedDecimal memory t;\n        t.d = x.d.divd(y.d);\n        return t;\n    }\n\n    /// @dev divide a signedDecimal by a int256\n    function divScalar(\n        signedDecimal memory x,\n        int256 y\n    ) internal pure returns (signedDecimal memory) {\n        signedDecimal memory t;\n        t.d = x.d / y;\n        return t;\n    }\n\n    /// @dev square root\n    function sqrt(\n        signedDecimal memory _y\n    ) internal pure returns (signedDecimal memory) {\n        int256 y = _y.d * 1e18;\n        int256 z;\n        if (y > 3) {\n            z = y;\n            int256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        return signedDecimal(z);\n    }\n}\n"
    },
    "contracts/utils/SignedDecimalMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.13;\n\n/// @dev Implements simple signed fixed point math add, sub, mul and div operations.\nlibrary SignedDecimalMath {\n    /// @dev Returns 1 in the fixed point representation, with `decimals` decimals.\n    function unit(uint8 decimals) internal pure returns (int256) {\n        return int256(10 ** uint256(decimals));\n    }\n\n    /// @dev Adds x and y, assuming they are both fixed point with 18 decimals.\n    function addd(int256 x, int256 y) internal pure returns (int256) {\n        return x + y;\n    }\n\n    /// @dev Subtracts y from x, assuming they are both fixed point with 18 decimals.\n    function subd(int256 x, int256 y) internal pure returns (int256) {\n        return x - y;\n    }\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with 18 digits.\n    function muld(int256 x, int256 y) internal pure returns (int256) {\n        return muld(x, y, 18);\n    }\n\n    /// @dev Multiplies x and y, assuming they are both fixed point with `decimals` digits.\n    function muld(\n        int256 x,\n        int256 y,\n        uint8 decimals\n    ) internal pure returns (int256) {\n        return (x * y) / unit(decimals);\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with 18 digits.\n    function divd(int256 x, int256 y) internal pure returns (int256) {\n        return divd(x, y, 18);\n    }\n\n    /// @dev Divides x between y, assuming they are both fixed point with `decimals` digits.\n    function divd(\n        int256 x,\n        int256 y,\n        uint8 decimals\n    ) internal pure returns (int256) {\n        return (x * unit(decimals)) / (y);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
